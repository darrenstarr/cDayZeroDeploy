<#
  .SYNOPSIS
      Basic MOF file parser
  
  .DESCRIPTION
      A basic MOF file parser. This parser is a recursive descent parser written without
      any tools such as a PEG generator. In addition, it was written from evaluating the
      format of the .MOF files generated by DSC from my other modules. It is not feature
      complete or name accurate as I didn't make use of the standards document which was
      over 50 pages of extreme details.
 
  .AUTHOR
      Darren R. Starr
 
  .COPYRIGHT
      2017 Conscia Norway AS
 
  .NOTES
      This code serves as a proof of concept that :
        a) Recursive descent parsers are practical to author in PowerShell
        b) A PEG generator would be meaningful for PowerShell and could be self-hosting as well
        c) I can still program :)

      The parser is layed out in three sections :
        - Generic parser support classes
        - Abstract Syntax Tree classes
        - The parser
#> 

<#=======================================================================
 #                 Generic parser support classes 
 #======================================================================#>

<#
    .SYNOPSIS
        A class to maintain the state of the parser, it is a basic stream management class at this point

    .NOTES
        It would be relatively easy to alter this class to be 100% self-contained, though the parser
        currently performs regular expressions, peeks and text grabs from the state.
#>
class ParserState {
    hidden [string]$SourceText
    [int]$Index = 0

    [System.Collections.Stack] $Stack = @()

    <#
        .SYNOPSIS
            Constructor
    #>    
    ParserState([string]$sourceText)
    {
        $this.SourceText = $sourceText
    }

    <#
        .SYNOPSIS
            Advances the read index by the given number of characters
    #>
    [void]Skip([int]$by)
    {
        $this.Index += $by
    }


    <#
        .SYNOPSIS
            Pushes the current state of this object
    #>
    [void]Push() {
        $this.Stack.Push($this.Index)
    }

    <#
        .SYNOPSIS
            Pops the previous state of this object

        .NOTES
            Before popping the stack is checked for pushed states. If there are no
            previous states on the stack, the function throws System.IndexOutOfRangeException
    #>
    [void]Pop() {
        if($this.Stack.Length -le 0) {
            throw [System.IndexOutOfRangeException]::new(
                'Parser state: No values left to pop'
            )
        }
        $this.Index = $this.Stack.Pop()    
    }

    <#
        .SYNOPSIS
            Commits the current state of the stack

        .NOTES
            Commits means that it simply pops the previous state of the stack
            without actually using it.
    #>
    [void]Commit() {
        if($this.Stack.Length -le 0) {
            throw [System.IndexOutOfRangeException]::new(
                'Parser state: No values left to pop'
            )
        }
        $this.Stack.Pop()
    }

    <#
        .SYNOPSIS
            Returns true when input is at or past end
    #>
    [bool]AtEnd()
    {
        return ($this.Index -ge $this.SourceText.Length)
    }

    <#
        .SYNOPSIS
            Returns the text at the given stream position with the given length

        .NOTES
            When an invalid start position or length is provided, then this function
            throws System.IndexOutOfRangeException
    #>
    [string]GetText([int]$startPosition, [int]$length)
    {
        if(
            ($startPosition -lt 0) -or
            ($length -lt 0) -or
            ($startPosition -ge $this.SourceText.Length) -or
            (($startPosition + $length - 1) -ge $this.SourceText.Length)
        ) {
            throw [System.IndexOutOfRangeException]::new(
                'An attempt has been made to retrieve data the is positioned outside of this text buffer'
            )
        }

        return $this.SourceText.Substring($startPosition, $length)
    }

    <#
        .SYNOPSIS
            Returns the next character in the stream and advances in the input pointer
        
        .NOTES
            If the stream position is at or past the end of the stream, this function
            throws System.IndexOutOfRangeException
    #>
    [string]GetNextChar()
    {
        if($this.AtEnd()) {
            throw [System.IndexOutOfRangeException]::new(
                'Input past end'
            )
        }

        [string]$result = $this.SourceText[$this.Index]

        $this.Index++

        return $result
    }


    <#
        .SYNOPSIS
            Matches the current position of the stream to the literal text provided.

        .DESCRIPTION
            The result of this function is position information regarding the position of the
            match and the length of the match.
    #>
    [ParserStateMatch]MatchLiteralText([string]$pattern)
    {
        $textIndex = $this.Index
        $patternIndex = 0

        while(
            ($textIndex -lt $this.SourceText.Length) -and 
            ($patternIndex -lt $pattern.Length) -and
            ($this.SourceText[$textIndex] -eq $pattern[$patternIndex])
        ) {
            $textIndex++
            $patternIndex++
        }

        $result = $null
        if ($patternIndex -eq $pattern.Length) {
            $result = [ParserStateMatch] @{
                State = $this
                StartIndex = $this.Index
                Length = $textIndex - $this.Index
            }
            $this.Skip($result.Length)
        }

        return $result
    }

    <#
        .SYNOPSIS
            Matches the text at the current position against the given regular expression

        .DESCRIPTION
            The result of this function is match criteria of what has been found, where and how long.

        .NOTES
            The current status of this function is that it is horribly inefficient because I can't find a method
            of reasonable intelligence to match the text from the index and only match from the given index.
    #>
    [ParserStateMatch]MatchExpression([string]$pattern)
    {
#        $match = [RegEx]::new('^' + $pattern).Match($this.SourceText, $this.Index)
        $match = [RegEx]::new($pattern).Match($this.SourceText, $this.Index)
        if ($null -eq $match) {
            return $null
        }
        
        if (-not $match.Success) {
            return $null
        }
        
        if ($match.Index -ne $this.Index) {
#            throw 'Oh shit, it doesn''t work like this'
            return $null
        }
        
        $result = [ParserStateMatch] @{
            State = $this
            StartIndex = $this.Index
            Length = $match.Length
        } 

        $this.Skip($result.Length)
        return $result
    }
}

<#
    .SYNOPSIS
        A structure for returning information regarding matched text within a parser stream.
#>
class ParserStateMatch {

    <#
        .SYNOPSIS
            The text stream in which the match occurs
    #>
    [ParserState]$State

    <#
        .SYNOPSIS
            The starting position of the text within the stream
    #>
    [int]$StartIndex

    <#
        .SYNOPSIS
            The length of the match
    #>
    [int]$Length

    <#
        .SYNOPSIS
            Returns the text represented by this match
    #>
    [string] GetText() {
        return $this.State.GetText($this.StartIndex, $this.Length)
    }
}

<#=======================================================================
 #                 Abstract Syntax Tree (AST) elements
 #=======================================================================#>

class MOFElement {
}

class MOFDocumentElement : MOFElement
{
}

class MOFDocument : MOFElement
{
    [MOFDocumentElement[]] $Elements = @()   
}

class MOFComment : MOFDocumentElement
{
    [string]$Comment

    MOFComment([ParserStateMatch]$match) 
    {
        $this.Comment = $match.GetText()
    }

    [string]ToString() {
        return $this.Comment
    }
}

class MOFInstanceOf : MOFDocumentElement
{
    [MOFLiteralName]$Name
    [MOFVariable]$As
    [MOFStructureValue]$Value

    MOFInstanceOf([MOFLiteralName]$name, [MOFInstanceOfAs]$as, [MOFStructureValue]$value)
    {
        $this.Name = $name
        if($null -ne $as) {
            $this.As = $as.Variable
        }

        $this.Value = $value
    }

    [string]ToString() {
        if($null -eq $this.As) {
            return $this.Name.ToString()
        } else {
            return ($this.Name.ToString() + ' as ' + $this.As.ToString())
        }
    }
}

class MOFValue : MOFElement
{
}

class MOFStringValue : MOFValue
{
    [string]$Value
    
    MOFStringValue([string]$value) {
        $this.Value = $value
    }

    [string]ToString() {
        return $this.Value
    }
}

class MOFIntegerValue : MOFValue
{
    [Int64]$Value

    MOFIntegerValue([Int64]$value) {
        $this.Value = $value
    }

    [string]ToString() {
        return $this.Value
    }    
}

class MOFBooleanValue : MOFValue
{
    [bool]$Value

    MOFBooleanValue([bool]$value) {
        $this.Value = $value
    }

    [string]ToString() {
        return $this.Value.ToString()
    }
}

class MOFVariable : MOFValue
{
    [string] $Name

    MOFVariable([string]$name)
    {
        $this.Name = $name
    }

    [string]ToString() {
        return $this.Name
    }
}

class MOFLiteralName : MOFElement
{
    [string] $Name

    MOFLiteralName([string]$name)
    {
        $this.Name = $name
    }

    [string]ToString() {
        return $this.Name
    }
}

class MOFInstanceOfAs : MOFElement
{
    [MOFVariable]$Variable

    MOFInstanceOfAs([MOFVariable]$variable)
    {
        $this.Variable = $variable
    }

    [string]ToString() {
        return $this.Variable.ToString()
    }
}

class MOFWhiteSpace : MOFDocumentElement
{
    [string] $Content

    MOFWhiteSpace([string]$content) 
    {
        $this.Content = $content
    }
}

class MOFAssignment : MOFElement
{
    [MOFLiteralName]$Name
    [MOFValue]$Value

    MOFAssignment([MOFLiteralName]$name, [MOFValue]$value) {
        $this.Name = $name
        $this.Value = $value
    }

    [string]ToString() {
        return ($this.Name.ToString() + ' = ' + $this.Value.ToString())
    }
}

class MOFStructureValue : MOFValue
{
    [MOFAssignment[]]$Values

    MOFStructureValue([MOFAssignment[]]$values) 
    {
        $this.Values = $values
    }

    [string]ToString() {
        return ('Structure, ' + $this.Values.Count + ' items')
    }
}

class MOFArrayValue : MOFValue
{
    [MOFValue[]]$Values

    MOFArrayValue([MOFValue[]]$values) 
    {
        $this.Values = $values
    }

    [string]ToString() {
        return $this.Values.ToString()
    }
}

<#=======================================================================
 #                 Generic parser support classes 
 #======================================================================#>

<#
    .SYNOPSIS
        A primitive MOF file parser

    .DESCRIPTION
        The purpose of this parse is to hopefully make it possible to find the DSC resource dependencies
        of a MOF file generated by a Powershell DSC configuration.

        This parser was hand-coded as there are no PEG tools available for generating Powershell classes.
        Although it is possible to use C# from Powershell, the overall goal of this project is to eliminate
        data center automation requirements needing other programming languages. And frankly, it's not 
        difficult to read or maintain a simple parse like this in Powershell.

    .ISSUES
        There is one major known issue with the parser which is that the regular MatchExpression code 
        which matches a regular expression seems impossible to implement using [RegEx]::match cleanly
        because it appears to be impossible to search from start of string (regex '^') from an initial
        index. So this code instead performs the search without the '^' and then compares the position of
        the match. This is ridiculously wrong to do. The better solution is likely to be to use Substring()
        however this could be an issue of mutability and have a very high cost of copying.

    .AUTHOR
        Darren R. Starr <darren dot starr _at= conscia d0t no>

    .NOTES
        The grammar of the parser as it currently stands is as follows :
            
            DocumentElements<MOFDocumentElement[]>
                = WS* element:DocumentElement elements:DocumentElements? { 
                    return [MOFDocumentElement[]] @(element, elements) 
                }

            DocumentElement<MOFDocumentElement>
                = c:Comment { return c }
                | i:InstanceOf { return i }

            InstanceOf<MOFInstanceOf> 
                = WS* 'instance' WS+ 'of' WS+ name:LiteralName as:InstanceOfAs? value:StructureValue WS* ';' {
                    return MOFInstanceOf::new(name, as, value)
                }
            
            StructureValue<MOFAssignment[]>
                = WS* '{' assignments:Assignments WS* '}' { return assignments }
            
            Assignments => 
                = assignment:Assignment assignments:Assignments? {
                    return [MOFAssignment[]] @( assignment, assignments )
                }
            
            Assignment<MOFAssignment>
                = WS* name:LiteralName WS* '=' value:Value WS* ';' {
                    return [MOFAssignment]::new(name, value)
                }
            
            Value<MOFValue>
                = variable:Variable { return variable }
                | stringValue:StringValue { return stringValue }
                | booleanValue:BooleanValue { return booleanValue }
                | arrayValue:ArrayValue { return arrayValue }
            
            ArrayValue<MOFValue[]>
                = WS* '{' values:ArrayValueItems WS* '}' { return values }
            
            ArrayValueItems<MOFValue[]>
                = value:Value WS* (',' values:Values)? { return [MOFValue[]] @(value, values) }
            
            BooleanValue<MOFBooleanValue>
                = WS* 'True' { return [MOFBooleanValue]::new($true) }
                | WS* 'False' { return [MOFBooleanValue]::new($false) }

            IntegerValue<MOFIntegerValue>
                = WS* '0x' hexValue:[0-9a-fA-F]+ { return [MOFIntegerValue]::new([Convert]::ToInt32($hexValue, 16)) }
                = WS* decimalValue:(-?[0-9]+) { return [MOFIntegerValue]::new([Convert]::ToInt32($decimalValue, 10)) }

            StringValue<MOFStringValue>
                = WS* '"' stringPart:StringPart? '"' { return [MOFStringValue]::new('' + stringPart.Value) }
            
            StringPart<MOFStringValue>
                = segment:StringPartSegment stringPart:StringPart? { return [MOFStringValue]new(segment.Value + stringPart.Value) }
            
            StringPartSegment<MOFStringValue>
                = escapedPart:EscapedStringPart { return escapedPart } 
                | stringPart:[^\\"]+ { return [MOFStringValue]::new(stringPart) }
            
            EscapedStringPart<MOFStringValue>
                = '\' escapedChar:. { return [MOFStringValue]::new(escapedChar) }
            
            InstanceOfAs<MOFInstanceOfAs>
                = WS* 'as' WS+ variable:Variable { return [MOFInstanceOfAs(variable) }
            
            Variable<MOFVariable>
                = WS* variable:'\$_?([A-Za-z][A-Za-z0-9_]*)' { return [MOFVariable]::new(variable) }
            
            LiteralName<MOFLiteralName>
                = name:'_?[A-Za-z][A-Za-z_]*' { return [MOFLiteralName]::new(name) }
            
            WS<MOFWhiteSpace>
                = ws:'\s+' { return [MOFWhiteSpace]::new(ws) }
            
            Comment<MOFComment>
                = blockComment:BlockComment { return blockComment }
            
            BlockComment<MOFComment>
                = blockComment:'\/\*(\*(?!\/)|[^*])*\*\/' { return [MOFComment]::new(blockComment) }
#>
class MOFParser {

    [MOFDocumentElement[]] Parse([string]$sourceText) 
    {
        [ParserState]$state = [ParserState]::new($sourceText)

        $result = $this.ParseDocumentElements($state) 

        if (-not $state.AtEnd()) {
            Write-Host $state.SourceText.Substring($state.Index)
            throw 'Did not make it to the end'
        }

        return $result
    }

    # DocumentElements => WS* DocumentElement DocumentElements? WS*
    hidden [MOFDocumentElement[]] ParseDocumentElements([ParserState]$state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)

        $matchDocumentElement = $this.ParseDocumentElement($state)
        if($null -eq $matchDocumentElement) {
            $state.Pop()
            return $null
        }

        [MOFDocumentElement[]]$result = [MOFDocumentElement[]]@($matchDocumentElement)

        $matchAdditionalElements = $this.ParseDocumentElements($state)
        if($null -ne $matchAdditionalElements) {
            $result += $matchAdditionalElements
        }

        $this.ParseWhiteSpace($state)

        $state.Commit()

        return $result
    }   

    # DocumentElement => Comment | InstanceOf
    hidden [MOFDocumentElement] ParseDocumentElement([ParserState]$state)
    {
        $matchComment = $this.ParseComment($state)
        if($null -ne $matchComment) {
            return $matchComment
        }

        $matchInstanceOf = $this.ParseInstanceOf($state)
        if($null -ne $matchInstanceOf) {
            return $matchInstanceOf
        }

        return $null
    }

    # InstanceOf => WS* 'instance' WS+ 'of' WS+ LiteralName InstanceOfAs? StructureValue WS* ';'
    hidden [MOFInstanceOf] ParseInstanceOf([ParserState]$state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)

        $matchInstance = $state.MatchLiteralText('instance')
        if ($null -eq $matchInstance) {
            $state.Pop()
            return $null
        }

        $matchWs = $this.ParseWhiteSpace($state) 
        if ($null -eq $matchWS) {
            $state.Pop()
            return $null
        }

        $matchOf = $state.MatchLiteralText('of')
        if ($null -eq $matchOf) {
            $state.Pop()
            return $null
        }
        
        $matchWs = $this.ParseWhiteSpace($state) 
        if ($null -eq $matchWS) {
            $state.Pop()
            return $null
        }

        $matchLiteralName = $this.ParseLiteralName($state)
        if ($null -eq $matchLiteralName) {
            $state.Pop()
            return $null
        }
        
        $matchAs = $this.ParseInstanceOfAs($state)

        $matchValue = $this.ParseStructureValue($state)
        if ($null -eq $matchValue) {
            $state.Pop()
            return $null
        }

        $this.ParseWhiteSpace($state)

        $matchSemicolon = $state.MatchLiteralText(';')
        if ($null -eq $matchSemicolon) {
            $state.Pop()
            return $null
        }

        $state.Commit()
        return [MOFInstanceOf]::new(
            $matchLiteralName,
            $matchAs,
            $matchValue
        )
    }

    # StructureValue => WS* '{' Assignments WS* '}'
    hidden [MOFStructureValue] ParseStructureValue([ParserState]$state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state) 

        if(-not $state.MatchLiteralText('{')) {
            $state.Pop()
            return $null
        }

        $matchAssignments = $this.parseAssignments($state)
        
        $this.ParseWhiteSpace($state)

        if(-not $state.MatchLiteralText('}')) {
            $state.Pop()
            return $null
        }

        $state.Commit()

        return [MOFStructureValue]::new(
            $matchAssignments
        )
    }

    # Assignments => Assignment Assignments?
    hidden [MOFAssignment[]] ParseAssignments([ParserState]$state)
    {
        $state.Push()

        $matchAssignment = $this.ParseAssignment($state)
        if($null -eq $matchAssignment) {
            $state.Pop()
            return $null
        }

        $result = @($matchAssignment)

        $matchAssignments = $this.ParseAssignments($state)

        if($null -ne $matchAssignments) {
            $result += $matchAssignments
        }

        $state.Commit()
        return $result
    }

    # Assignment => WS* LiteralName WS* '=' Value WS* ';'
    hidden [MOFAssignment] ParseAssignment([ParserState] $state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)

        $matchLiteralName = $this.ParseLiteralName($state)
        if($null -eq $matchLiteralName) {
            $state.Pop()
            return $null
        }

        $this.ParseWhiteSpace($state)

        $matchAssignmentOperator = $state.MatchLiteralText('=')
        if($null -eq $matchAssignmentOperator) {
            $state.Pop()
            return $null
        }

        $matchValue = $this.ParseValue($state)
        if($null -eq $matchValue) {
            $state.Pop()
            return $null
        }

        $this.ParseWhiteSpace($state)

        $matchSemicolon = $state.MatchLiteralText(';')
        if($null -eq $matchSemicolon) {
            $state.Pop()
            return $null
        }

        $state.Commit()

        return [MOFAssignment]::new(
            $matchLiteralName,
            $matchValue
        )
    }

    # Value => Variable | StringValue | BooleanValue | IntegerValue | ArrayValue
    hidden [MOFValue] ParseValue([ParserState]$state)
    {
        $state.Push()

        $variableValue = $this.ParseVariable($state)
        if($null -ne $variableValue) {
            $state.Commit()
            return $variableValue
        }

        $stringValue = $this.ParseStringValue($state)
        if($null -ne $stringValue) {
            $state.Commit()
            return $stringValue
        }

        $booleanValue = $this.ParseBooleanValue($state)
        if($null -ne $booleanValue) {
            $state.Commit()
            return $booleanValue
        }

        $integerValue = $this.ParseIntegerValue($state)
        if($null -ne $integerValue) {
            $state.Commit()
            return $integerValue
        }

        $arrayValue = $this.ParseArrayValue($state)
        if($null -ne $arrayValue) {
            $state.Commit()
            return $arrayValue
        }

        Write-Host 'Unhandled value'

        $state.Pop()
        return $null
    }

    # IntegerValue => WS* ('0x' [0-9a-fA-F]+)|(-?[0-9]+) 
    hidden [MOFIntegerValue] ParseIntegerValue([ParserState] $state)
    {
        $hexValue = $this.ParseHexIntegerValue($state)
        if($null -ne $hexValue) {
            return $hexValue
        }

        $decimalValue = $this.ParseDecimalIntegerValue($state)
        if($null -ne $decimalValue) {
            return $decimalValue
        }

        return $null
    }

    hidden [MOFIntegerValue] ParseHexIntegerValue($state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)
        
        $matchZeroX = $state.MatchLiteralText('0x')
        if($null -eq $matchZeroX) {
            $state.Pop()
            return $null
        }

        $matchHexValue = $state.MatchExpression('[0-9a-fA-F]{1:16}')
        if($null -eq $matchHexValue) {
            $state.Pop()
            return $null
        }

        $state.Commit()
        return [MOFIntegerValue]::new([Convert]::ToInt64($matchHexValue.GetText(), 16))
    }

    hidden [MOFIntegerValue] ParseDecimalIntegerValue($state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)
        
        $matchDecimalValue = $state.MatchExpression('-?[0-9]+')
        if($null -eq $matchDecimalValue) {
            $state.Pop()
            return $null
        }

        $decimalValue = $null
        try {
            $decimalValue = [Convert]::ToInt64($matchDecimalValue.GetText(), 10)
        } catch {
            Write-Host 'oops'
        }

        # TODO : Better checking of out of range here
        if([Convert]::ToInt64([Convert]::ToString($decimalValue)) -ne $decimalValue) {
            throw [System.ArgumentOutOfRangeException]::new(
                'Integer value out of range'
            )
        }

        $state.Commit()
        return [MOFIntegerValue]::new($decimalValue)
    }

    # ArrayValue => WS* '{' ArrayValueItems WS* '}'
    hidden [MOFArrayValue] ParseArrayValue([ParserState]$state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)

        $matchOpenBrace = $state.MatchLiteralText('{')
        if($null -eq $matchOpenBrace) {
            $state.Pop()
            return $null
        }

        $values = $this.ParseArrayValueItems($state)

        $this.ParseWhiteSpace($state)

        $matchCloseBrace = $state.MatchLiteralText('}')
        if($null -eq $matchCloseBrace) {
            $state.Pop()
            return $null
        }

        $state.Commit()
        return $values
    }

    # ArrayValueItems => Value WS* (',' Values)?
    hidden [MOFArrayValue] ParseArrayValueItems([ParserState]$state)
    {
        $state.Push()

        $values = [MOFValue[]]@()

        $value = $this.ParseValue($state)
        if($null -eq $value) {
            $state.Commit()
            return [MOFArrayValue]::new($values)
        }

        $values += $value

        $matchComma = $state.MatchLiteralText(',')
        if($null -ne $matchComma) {
            $matchValues = $this.ParseArrayValueItems($state)
            if($null -eq $matchValues) {
                throw [Exception]::new(
                    'Expected value'
                )
            }

            $values += $matchValues.Values
        }

        $state.Commit()
        return [MOFArrayValue]::new($values)
    }

    # BooleanValue => WS* ('True'|'False')
    hidden [MOFBooleanValue] ParseBooleanValue([ParserState]$state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)

        $matchTrue = $state.MatchLiteralText('True')
        if($null -ne $matchTrue) {
            $state.Commit()
            return [MOFBooleanValue]::new($true)
        }

        $matchFalse = $state.MatchLiteralText('False')
        if($null -ne $matchFalse) {
            $state.Commit()
            return [MOFBooleanValue]::new($false)
        }

        $state.Pop()
        return $null
    }

    # StringValue => WS* '"' StringPart? '"'
    hidden [MOFStringValue] ParseStringValue([ParserState]$state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)

        $matchStartingQuote = $state.MatchLiteralText('"')
        if($null -eq $matchStartingQuote) {
            $state.Pop()
            return $null
        }

        $result = [MOFStringValue]::new('')

        $matchStringPart = $this.ParseStringPart($state)
        if($null -ne $matchStringPart) {
            $result = $matchStringPart
        } 

        $matchStartingQuote = $state.MatchLiteralText('"')
        if($null -eq $matchStartingQuote) {
            $state.Pop()
            return $null
        }

        $state.Commit()

        return $result
    }

    # StringPart => StringPartSegment StringPart?
    hidden [MOFStringValue] ParseStringPart([ParserState]$state)
    {
        $state.Push()

        $matchStringPart = $this.ParseStringPartSegment($state)
        if($null -eq $matchStringPart) {
            $state.Pop()
            return $null
        }

        $nextStringPart = $this.ParseStringPart($state)
        if($null -ne $nextStringPart) {
            $matchStringPart.Value += $nextStringPart.Value
        }

        $state.Commit()

        return $matchStringPart
    }

    # StringPartSegment => EscapedStringPart | [^\\"]+
    hidden [MOFStringValue] ParseStringPartSegment([ParserState]$state)
    {
        $matchEscapedStringPart = $this.ParseEscapedStringPart($state)
        if($null -ne $matchEscapedStringPart) {
            return $matchEscapedStringPart
        }

        $matchStringPartExpression = $state.MatchExpression('[^\\"]+')
        if($null -ne $matchStringPartExpression) {
            return [MOFStringValue]::new(
                $matchStringPartExpression.GetText()
            )
        }

        return $null
    }

    # EscapedStringPart => '\' .
    hidden [MOFStringValue] ParseEscapedStringPart([ParserState]$state)
    {
        $state.Push()

        $matchBackslash = $state.MatchLiteralText('\')
        if($null -eq $matchBackslash) {
            $state.Pop()
            return $null
        }

        if($state.AtEnd()) {
            $state.Pop()
            return $null
        }

        $nextChar = $state.GetNextChar()

        # TODO : Handle more complex escape sequences... like \u001B

        $state.Commit()

        return [MOFStringValue]::new($nextChar)
    }

    # InstanceOfAs => WS* 'as' WS+ Variable
    hidden [MOFInstanceOfAs] ParseInstanceOfAs([ParserState]$state)
    {
        $state.Push()

        $matchWs = $this.ParseWhiteSpace($state)
        if($null -eq $matchWs) {
            $state.Pop()
            return $null
        }

        $matchAs = $state.MatchLiteralText('as')
        if($null -eq $matchAs) {
            $state.Pop()
            return $null
        }

        $matchWs = $this.ParseWhiteSpace($state)
        if($null -eq $matchWs) {
            $state.Pop()
            return $null
        }

        $matchVariable = $this.ParseVariable([ParserState]$state)
        if($null -eq $matchVariable) {
            $state.Pop()
            return $null
        }

        $state.Commit()

        return [MOFInstanceOfAs]::new($matchVariable)
    }

    # Variable => WS* '\$_?([A-Za-z][A-Za-z0-9_]*)'
    hidden [MOFVariable] ParseVariable([ParserState]$state)
    {
        $state.Push()
        $this.ParseWhiteSpace($state)

        $matchVariable = $state.MatchExpression('\$_?([A-Za-z][A-Za-z0-9_]*)')
        if ($null -eq $matchVariable) {
            $state.Pop()
            return $null
        }

        $result = [MOFVariable]::new(
            $matchVariable.GetText()
        )

        $state.Commit()

        return $result
    }
    
    # LiteralName = '_?[A-Za-z][A-Za-z_]*'
    hidden [MOFLiteralName] ParseLiteralName([ParserState]$state)
    {
        $matchLiteralName = $state.MatchExpression('_?[A-Za-z][A-Za-z_]*')
        if ($null -eq $matchLiteralName) {
            return $null
        }

        $result = [MOFLiteralName]::new(
            $matchLiteralName.GetText()
        )

        return $result
    }

    # WS = '\s+'
    hidden [MOFWhiteSpace] ParseWhiteSpace([ParserState]$state)
    {
        $matchWhitespace = $state.MatchExpression('\s+')
        if ($null -ne $matchWhitespace) {
            $result = [MOFWhiteSpace]::new(
                $matchWhiteSpace.GetText()
            )

            return $result
        }

        return $null
    }

    # Comment => BlockComment
    hidden [MOFComment] ParseComment([ParserState]$state)
    {
        $parseBlockComment = $this.ParseBlockComment($state)
        if($null -ne $parseBlockComment) {
            return $parseBlockComment
        }

        return $null
    }

    # BlockComment => '\/\*(\*(?!\/)|[^*])*\*\/'
    hidden [MOFComment] ParseBlockComment([ParserState]$state)
    {
        # Attempt to match multi-line comments
        $matchComment = $state.MatchExpression('\/\*(\*(?!\/)|[^*])*\*\/')
        if ($null -ne $matchComment) {
            return [MOFComment]::new(
                $matchComment
            )
        }

        return $null
    }
}

