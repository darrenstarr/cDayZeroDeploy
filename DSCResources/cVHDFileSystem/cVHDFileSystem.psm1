# ---------------------------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE - THIS IS A GENERATED FILE
# ------
# This file is generated by HelperScripts/buildPSM.ps1 by combining the source files from the project
# into this one script.
# ---------------------------------------------------------------------------------------------------
<#
  .SYNOPSIS
      Basic MOF file parser
  
  .DESCRIPTION
      A basic MOF file parser. This parser is a recursive descent parser written without
      any tools such as a PEG generator. In addition, it was written from evaluating the
      format of the .MOF files generated by DSC from my other modules. It is not feature
      complete or name accurate as I didn't make use of the standards document which was
      over 50 pages of extreme details.
 
  .AUTHOR
      Darren R. Starr
 
  .COPYRIGHT
      2017 Conscia Norway AS
 
  .NOTES
      This code serves as a proof of concept that :
        a) Recursive descent parsers are practical to author in PowerShell
        b) A PEG generator would be meaningful for PowerShell and could be self-hosting as well
        c) I can still program :)

      The parser is layed out in three sections :
        - Generic parser support classes
        - Abstract Syntax Tree classes
        - The parser
#> 

<#=======================================================================
 #                 Generic parser support classes 
 #======================================================================#>

<#
    .SYNOPSIS
        A class to maintain the state of the parser, it is a basic stream management class at this point

    .DESCRIPTION
        This class is a combination of a stream and a state manager. ParserState stores the full text
        of the file to parse and also the current index within the text. As part of the class, there
        are functions used for pushing and popping the state (currently by managing a stack of indexes)
        and also functions for matching literals and regular expressions.

    .NOTES
        A later version should include
            <li>Translation of index to line and column number</li>
            <li>Injecting 'includes' within the text at the current state. On Pop(), the include should be undone</li>
#>
class ParserState {
    <#
        .SYNOPSIS
            The text to parse
    #>
    hidden [string]$SourceText

    <#
        .SYNOPSIS
            The current index within the text
    #>
    hidden [int]$Index = 0

    <#
        .SYNOPSIS
            The state stack. Allowing pushes and pops of the current parser state
    #>
    hidden [System.Collections.Stack] $Stack = @()

    <#
        .SYNOPSIS
            Constructor
    #>    
    ParserState([string]$sourceText)
    {
        $this.SourceText = $sourceText
    }

    <#
        .SYNOPSIS
            Advances the read index by the given number of characters
    #>
    [void]Skip([int]$by)
    {
        $this.Index += $by
    }


    <#
        .SYNOPSIS
            Pushes the current state of this object
    #>
    [void]Push() {
        $this.Stack.Push($this.Index)
    }

    <#
        .SYNOPSIS
            Pops the previous state of this object

        .NOTES
            Before popping the stack is checked for pushed states. If there are no
            previous states on the stack, the function throws System.IndexOutOfRangeException
    #>
    [void]Pop() {
        if($this.Stack.Length -le 0) {
            throw [System.IndexOutOfRangeException]::new(
                'Parser state: No values left to pop'
            )
        }
        $this.Index = $this.Stack.Pop()    
    }

    <#
        .SYNOPSIS
            Commits the current state of the stack

        .NOTES
            Commits means that it simply pops the previous state of the stack
            without actually using it.
    #>
    [void]Commit() {
        if($this.Stack.Length -le 0) {
            throw [System.IndexOutOfRangeException]::new(
                'Parser state: No values left to pop'
            )
        }
        $this.Stack.Pop()
    }

    <#
        .SYNOPSIS
            Returns true when input is at or past end
    #>
    [bool]AtEnd()
    {
        return ($this.Index -ge $this.SourceText.Length)
    }

    <#
        .SYNOPSIS
            Returns the text at the given stream position with the given length

        .NOTES
            When an invalid start position or length is provided, then this function
            throws System.IndexOutOfRangeException
    #>
    [string]GetText([int]$startPosition, [int]$length)
    {
        if(
            ($startPosition -lt 0) -or
            ($length -lt 0) -or
            ($startPosition -ge $this.SourceText.Length) -or
            (($startPosition + $length - 1) -ge $this.SourceText.Length)
        ) {
            throw [System.IndexOutOfRangeException]::new(
                'An attempt has been made to retrieve data the is positioned outside of this text buffer'
            )
        }

        return $this.SourceText.Substring($startPosition, $length)
    }

    <#
        .SYNOPSIS
            Returns the next character in the stream and advances in the input pointer
        
        .NOTES
            If the stream position is at or past the end of the stream, this function
            throws System.IndexOutOfRangeException
    #>
    [string]GetNextChar()
    {
        if($this.AtEnd()) {
            throw [System.IndexOutOfRangeException]::new(
                'Input past end'
            )
        }

        [string]$result = $this.SourceText[$this.Index]

        $this.Index++

        return $result
    }


    <#
        .SYNOPSIS
            Matches the current position of the stream to the literal text provided.

        .DESCRIPTION
            The result of this function is position information regarding the position of the
            match and the length of the match.
    #>
    [ParserStateMatch]MatchLiteralText([string]$pattern)
    {
        $textIndex = $this.Index
        $patternIndex = 0

        while(
            ($textIndex -lt $this.SourceText.Length) -and 
            ($patternIndex -lt $pattern.Length) -and
            ($this.SourceText[$textIndex] -eq $pattern[$patternIndex])
        ) {
            $textIndex++
            $patternIndex++
        }

        $result = $null
        if ($patternIndex -eq $pattern.Length) {
            $result = [ParserStateMatch] @{
                State = $this
                StartIndex = $this.Index
                Length = $textIndex - $this.Index
            }
            $this.Skip($result.Length)
        }

        return $result
    }

    <#
        .SYNOPSIS
            Matches the text at the current position against the given regular expression

        .DESCRIPTION
            The result of this function is match criteria of what has been found, where and how long.
    #>
    [ParserStateMatch]MatchExpression([string]$pattern)
    {
        $match = [RegEx]::new('\G' + $pattern).Match($this.SourceText, $this.Index)
        if ($null -eq $match) {
            return $null
        }
        
        if (-not $match.Success) {
            return $null
        }
        
        $result = [ParserStateMatch] @{
            State = $this
            StartIndex = $this.Index
            Length = $match.Length
        } 

        $this.Skip($result.Length)
        return $result
    }
}

<#
    .SYNOPSIS
        A structure for returning information regarding matched text within a parser stream.
#>
class ParserStateMatch {

    <#
        .SYNOPSIS
            The text stream in which the match occurs
    #>
    [ParserState]$State

    <#
        .SYNOPSIS
            The starting position of the text within the stream
    #>
    [int]$StartIndex

    <#
        .SYNOPSIS
            The length of the match
    #>
    [int]$Length

    <#
        .SYNOPSIS
            Returns the text represented by this match
    #>
    [string] GetText() {
        return $this.State.GetText($this.StartIndex, $this.Length)
    }
}

<#=======================================================================
 #                 Abstract Syntax Tree (AST) elements
 #=======================================================================#>

class MOFElement {
}

class MOFDocumentElement : MOFElement
{
}

class MOFDocument : MOFElement
{
    [MOFDocumentElement[]] $Elements = @()   
}

class MOFComment : MOFDocumentElement
{
    [string]$Comment

    MOFComment([ParserStateMatch]$match) 
    {
        $this.Comment = $match.GetText()
    }

    [string]ToString() {
        return $this.Comment
    }
}

class MOFInstanceOf : MOFDocumentElement
{
    [MOFLiteralName]$Name
    [MOFVariable]$As
    [MOFStructureValue]$Value

    MOFInstanceOf([MOFLiteralName]$name, [MOFInstanceOfAs]$as, [MOFStructureValue]$value)
    {
        $this.Name = $name
        if($null -ne $as) {
            $this.As = $as.Variable
        }

        $this.Value = $value
    }

    [string]ToString() {
        if($null -eq $this.As) {
            return $this.Name.ToString()
        } else {
            return ($this.Name.ToString() + ' as ' + $this.As.ToString())
        }
    }
}

class MOFValue : MOFElement
{
}

class MOFStringValue : MOFValue
{
    [string]$Value
    
    MOFStringValue([string]$value) {
        $this.Value = $value
    }

    [string]ToString() {
        return $this.Value
    }
}

class MOFIntegerValue : MOFValue
{
    [Int64]$Value

    MOFIntegerValue([Int64]$value) {
        $this.Value = $value
    }

    [string]ToString() {
        return $this.Value
    }    
}

class MOFBooleanValue : MOFValue
{
    [bool]$Value

    MOFBooleanValue([bool]$value) {
        $this.Value = $value
    }

    [string]ToString() {
        return $this.Value.ToString()
    }
}

class MOFVariable : MOFValue
{
    [string] $Name

    MOFVariable([string]$name)
    {
        $this.Name = $name
    }

    [string]ToString() {
        return $this.Name
    }
}

class MOFLiteralName : MOFElement
{
    [string] $Name

    MOFLiteralName([string]$name)
    {
        $this.Name = $name
    }

    [string]ToString() {
        return $this.Name
    }
}

class MOFInstanceOfAs : MOFElement
{
    [MOFVariable]$Variable

    MOFInstanceOfAs([MOFVariable]$variable)
    {
        $this.Variable = $variable
    }

    [string]ToString() {
        return $this.Variable.ToString()
    }
}

class MOFWhiteSpace : MOFDocumentElement
{
    [string] $Content

    MOFWhiteSpace([string]$content) 
    {
        $this.Content = $content
    }
}

class MOFAssignment : MOFElement
{
    [MOFLiteralName]$Name
    [MOFValue]$Value

    MOFAssignment([MOFLiteralName]$name, [MOFValue]$value) {
        $this.Name = $name
        $this.Value = $value
    }

    [string]ToString() {
        return ($this.Name.ToString() + ' = ' + $this.Value.ToString())
    }
}

class MOFStructureValue : MOFValue
{
    [MOFAssignment[]]$Values

    MOFStructureValue([MOFAssignment[]]$values) 
    {
        $this.Values = $values
    }

    [string]ToString() {
        return ('Structure, ' + $this.Values.Count + ' items')
    }
}

class MOFArrayValue : MOFValue
{
    [MOFValue[]]$Values

    MOFArrayValue([MOFValue[]]$values) 
    {
        $this.Values = $values
    }

    [string]ToString() {
        return $this.Values.ToString()
    }
}

<#=======================================================================
 #                 Generic parser support classes 
 #======================================================================#>

<#
    .SYNOPSIS
        A primitive MOF file parser

    .DESCRIPTION
        The purpose of this parse is to hopefully make it possible to find the DSC resource dependencies
        of a MOF file generated by a Powershell DSC configuration.

        This parser was hand-coded as there are no PEG tools available for generating Powershell classes.
        Although it is possible to use C# from Powershell, the overall goal of this project is to eliminate
        data center automation requirements needing other programming languages. And frankly, it's not 
        difficult to read or maintain a simple parse like this in Powershell.

    .ISSUES
        There is one major known issue with the parser which is that the regular MatchExpression code 
        which matches a regular expression seems impossible to implement using [RegEx]::match cleanly
        because it appears to be impossible to search from start of string (regex '^') from an initial
        index. So this code instead performs the search without the '^' and then compares the position of
        the match. This is ridiculously wrong to do. The better solution is likely to be to use Substring()
        however this could be an issue of mutability and have a very high cost of copying.

    .AUTHOR
        Darren R. Starr <darren dot starr _at= conscia d0t no>

    .NOTES
        The grammar of the parser as it currently stands is as follows :
            
            DocumentElements<MOFDocumentElement[]>
                = WS* element:DocumentElement elements:DocumentElements? WS* { 
                    return [MOFDocumentElement[]] @(element, elements) 
                }

            DocumentElement<MOFDocumentElement>
                = c:Comment { return c }
                | i:InstanceOf { return i }

            InstanceOf<MOFInstanceOf> 
                = WS* 'instance' WS+ 'of' WS+ name:LiteralName as:InstanceOfAs? value:StructureValue WS* ';' {
                    return MOFInstanceOf::new(name, as, value)
                }
            
            StructureValue<MOFAssignment[]>
                = WS* '{' assignments:Assignments WS* '}' { return assignments }
            
            Assignments => 
                = assignment:Assignment assignments:Assignments? {
                    return [MOFAssignment[]] @( assignment, assignments )
                }
            
            Assignment<MOFAssignment>
                = WS* name:LiteralName WS* '=' value:Value WS* ';' {
                    return [MOFAssignment]::new(name, value)
                }
            
            Value<MOFValue>
                = variable:Variable { return variable }
                | stringValue:StringValue { return stringValue }
                | booleanValue:BooleanValue { return booleanValue }
                | arrayValue:ArrayValue { return arrayValue }
            
            ArrayValue<MOFValue[]>
                = WS* '{' values:ArrayValueItems WS* '}' { return values }
            
            ArrayValueItems<MOFValue[]>
                = value:Value WS* (',' values:Values)? { return [MOFValue[]] @(value, values) }
            
            BooleanValue<MOFBooleanValue>
                = WS* 'True' { return [MOFBooleanValue]::new($true) }
                | WS* 'False' { return [MOFBooleanValue]::new($false) }

            IntegerValue<MOFIntegerValue>
                = hexValue:HexIntegerValue { return hexValue }
                | decimalValue:DecimalIntegerValue { return decimalValue }

            HexIntegerValue<MOFIntegerValue>
                = WS* '0x' hexValue:[0-9a-fA-F]+ { return [MOFIntegerValue]::new([Convert]::ToInt64($hexValue, 16)) }

            DecimalIntegerValue<MOFIntegerValue>
                = WS* decimalValue:(-?[0-9]+) { return [MOFIntegerValue]::new([Convert]::ToInt64($decimalValue, 10)) }

            StringValue<MOFStringValue>
                = WS* '"' stringPart:StringPart? '"' { return [MOFStringValue]::new('' + stringPart.Value) }
            
            StringPart<MOFStringValue>
                = segment:StringPartSegment stringPart:StringPart? { return [MOFStringValue]new(segment.Value + stringPart.Value) }
            
            StringPartSegment<MOFStringValue>
                = escapedPart:EscapedStringPart { return escapedPart } 
                | stringPart:[^\\"]+ { return [MOFStringValue]::new(stringPart) }
            
            EscapedStringPart<MOFStringValue>
                = '\' escapedChar:. { return [MOFStringValue]::new(escapedChar) }
            
            InstanceOfAs<MOFInstanceOfAs>
                = WS* 'as' WS+ variable:Variable { return [MOFInstanceOfAs(variable) }
            
            Variable<MOFVariable>
                = WS* variable:'\$_?([A-Za-z][A-Za-z0-9_]*)' { return [MOFVariable]::new(variable) }
            
            LiteralName<MOFLiteralName>
                = name:'_?[A-Za-z][A-Za-z_]*' { return [MOFLiteralName]::new(name) }
            
            WS<MOFWhiteSpace>
                = ws:'\s+' { return [MOFWhiteSpace]::new(ws) }
            
            Comment<MOFComment>
                = blockComment:BlockComment { return blockComment }
            
            BlockComment<MOFComment>
                = blockComment:'\/\*(\*(?!\/)|[^*])*\*\/' { return [MOFComment]::new(blockComment) }
#>
class MOFParser {

    [MOFDocumentElement[]] Parse([string]$sourceText) 
    {
        [ParserState]$state = [ParserState]::new($sourceText)

        $result = $this.ParseDocumentElements($state) 

        if (-not $state.AtEnd()) {
            throw 'Did not make it to the end'
        }

        return $result
    }

    # DocumentElements => WS* DocumentElement DocumentElements? WS*
    hidden [MOFDocumentElement[]] ParseDocumentElements([ParserState]$state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)

        $matchDocumentElement = $this.ParseDocumentElement($state)
        if($null -eq $matchDocumentElement) {
            $state.Pop()
            return $null
        }

        [MOFDocumentElement[]]$result = [MOFDocumentElement[]]@($matchDocumentElement)

        $matchAdditionalElements = $this.ParseDocumentElements($state)
        if($null -ne $matchAdditionalElements) {
            $result += $matchAdditionalElements
        }

        $this.ParseWhiteSpace($state)

        $state.Commit()

        return $result
    }   

    # DocumentElement => Comment | InstanceOf
    hidden [MOFDocumentElement] ParseDocumentElement([ParserState]$state)
    {
        $matchComment = $this.ParseComment($state)
        if($null -ne $matchComment) {
            return $matchComment
        }

        $matchInstanceOf = $this.ParseInstanceOf($state)
        if($null -ne $matchInstanceOf) {
            return $matchInstanceOf
        }

        return $null
    }

    # InstanceOf => WS* 'instance' WS+ 'of' WS+ LiteralName InstanceOfAs? StructureValue WS* ';'
    hidden [MOFInstanceOf] ParseInstanceOf([ParserState]$state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)

        $matchInstance = $state.MatchLiteralText('instance')
        if ($null -eq $matchInstance) {
            $state.Pop()
            return $null
        }

        $matchWs = $this.ParseWhiteSpace($state) 
        if ($null -eq $matchWS) {
            $state.Pop()
            return $null
        }

        $matchOf = $state.MatchLiteralText('of')
        if ($null -eq $matchOf) {
            $state.Pop()
            return $null
        }
        
        $matchWs = $this.ParseWhiteSpace($state) 
        if ($null -eq $matchWS) {
            $state.Pop()
            return $null
        }

        $matchLiteralName = $this.ParseLiteralName($state)
        if ($null -eq $matchLiteralName) {
            $state.Pop()
            return $null
        }
        
        $matchAs = $this.ParseInstanceOfAs($state)

        $matchValue = $this.ParseStructureValue($state)
        if ($null -eq $matchValue) {
            $state.Pop()
            return $null
        }

        $this.ParseWhiteSpace($state)

        $matchSemicolon = $state.MatchLiteralText(';')
        if ($null -eq $matchSemicolon) {
            $state.Pop()
            return $null
        }

        $state.Commit()
        return [MOFInstanceOf]::new(
            $matchLiteralName,
            $matchAs,
            $matchValue
        )
    }

    # StructureValue => WS* '{' Assignments WS* '}'
    hidden [MOFStructureValue] ParseStructureValue([ParserState]$state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state) 

        if(-not $state.MatchLiteralText('{')) {
            $state.Pop()
            return $null
        }

        $matchAssignments = $this.parseAssignments($state)
        
        $this.ParseWhiteSpace($state)

        if(-not $state.MatchLiteralText('}')) {
            $state.Pop()
            return $null
        }

        $state.Commit()

        return [MOFStructureValue]::new(
            $matchAssignments
        )
    }

    # Assignments => Assignment Assignments?
    hidden [MOFAssignment[]] ParseAssignments([ParserState]$state)
    {
        $state.Push()

        $matchAssignment = $this.ParseAssignment($state)
        if($null -eq $matchAssignment) {
            $state.Pop()
            return $null
        }

        $result = @($matchAssignment)

        $matchAssignments = $this.ParseAssignments($state)

        if($null -ne $matchAssignments) {
            $result += $matchAssignments
        }

        $state.Commit()
        return $result
    }

    # Assignment => WS* LiteralName WS* '=' Value WS* ';'
    hidden [MOFAssignment] ParseAssignment([ParserState] $state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)

        $matchLiteralName = $this.ParseLiteralName($state)
        if($null -eq $matchLiteralName) {
            $state.Pop()
            return $null
        }

        $this.ParseWhiteSpace($state)

        $matchAssignmentOperator = $state.MatchLiteralText('=')
        if($null -eq $matchAssignmentOperator) {
            $state.Pop()
            return $null
        }

        $matchValue = $this.ParseValue($state)
        if($null -eq $matchValue) {
            $state.Pop()
            return $null
        }

        $this.ParseWhiteSpace($state)

        $matchSemicolon = $state.MatchLiteralText(';')
        if($null -eq $matchSemicolon) {
            $state.Pop()
            return $null
        }

        $state.Commit()

        return [MOFAssignment]::new(
            $matchLiteralName,
            $matchValue
        )
    }

    # Value => Variable | StringValue | BooleanValue | IntegerValue | ArrayValue
    hidden [MOFValue] ParseValue([ParserState]$state)
    {
        $state.Push()

        $variableValue = $this.ParseVariable($state)
        if($null -ne $variableValue) {
            $state.Commit()
            return $variableValue
        }

        $stringValue = $this.ParseStringValue($state)
        if($null -ne $stringValue) {
            $state.Commit()
            return $stringValue
        }

        $booleanValue = $this.ParseBooleanValue($state)
        if($null -ne $booleanValue) {
            $state.Commit()
            return $booleanValue
        }

        $integerValue = $this.ParseIntegerValue($state)
        if($null -ne $integerValue) {
            $state.Commit()
            return $integerValue
        }

        $arrayValue = $this.ParseArrayValue($state)
        if($null -ne $arrayValue) {
            $state.Commit()
            return $arrayValue
        }

        Write-Host 'Unhandled value'

        $state.Pop()
        return $null
    }

    # IntegerValue => HexIntegerValue | DecimalIntegerValue 
    hidden [MOFIntegerValue] ParseIntegerValue([ParserState] $state)
    {
        $hexValue = $this.ParseHexIntegerValue($state)
        if($null -ne $hexValue) {
            return $hexValue
        }

        $decimalValue = $this.ParseDecimalIntegerValue($state)
        if($null -ne $decimalValue) {
            return $decimalValue
        }

        return $null
    }

    # HexIntegerValue = WS* '0x' [0-9a-fA-F]+
    hidden [MOFIntegerValue] ParseHexIntegerValue($state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)
        
        $matchZeroX = $state.MatchLiteralText('0x')
        if($null -eq $matchZeroX) {
            $state.Pop()
            return $null
        }

        $matchHexValue = $state.MatchExpression('[0-9a-fA-F]{1:16}')
        if($null -eq $matchHexValue) {
            $state.Pop()
            return $null
        }

        $state.Commit()
        return [MOFIntegerValue]::new([Convert]::ToInt64($matchHexValue.GetText(), 16))
    }

    # DecimalIntegerValue = WS* -?[0-9]+
    hidden [MOFIntegerValue] ParseDecimalIntegerValue($state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)
        
        $matchDecimalValue = $state.MatchExpression('-?[0-9]+')
        if($null -eq $matchDecimalValue) {
            $state.Pop()
            return $null
        }

        $decimalValue = $null
        try {
            $decimalValue = [Convert]::ToInt64($matchDecimalValue.GetText(), 10)
        } catch {
            Write-Host 'oops'
        }

        # TODO : Better checking of out of range here
        if([Convert]::ToInt64([Convert]::ToString($decimalValue)) -ne $decimalValue) {
            throw [System.ArgumentOutOfRangeException]::new(
                'Integer value out of range'
            )
        }

        $state.Commit()
        return [MOFIntegerValue]::new($decimalValue)
    }

    # ArrayValue => WS* '{' ArrayValueItems WS* '}'
    hidden [MOFArrayValue] ParseArrayValue([ParserState]$state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)

        $matchOpenBrace = $state.MatchLiteralText('{')
        if($null -eq $matchOpenBrace) {
            $state.Pop()
            return $null
        }

        $values = $this.ParseArrayValueItems($state)

        $this.ParseWhiteSpace($state)

        $matchCloseBrace = $state.MatchLiteralText('}')
        if($null -eq $matchCloseBrace) {
            $state.Pop()
            return $null
        }

        $state.Commit()
        return $values
    }

    # ArrayValueItems => Value WS* (',' Values)?
    hidden [MOFArrayValue] ParseArrayValueItems([ParserState]$state)
    {
        $state.Push()

        $values = [MOFValue[]]@()

        $value = $this.ParseValue($state)
        if($null -eq $value) {
            $state.Commit()
            return [MOFArrayValue]::new($values)
        }

        $values += $value

        $matchComma = $state.MatchLiteralText(',')
        if($null -ne $matchComma) {
            $matchValues = $this.ParseArrayValueItems($state)
            if($null -eq $matchValues) {
                throw [Exception]::new(
                    'Expected value'
                )
            }

            $values += $matchValues.Values
        }

        $state.Commit()
        return [MOFArrayValue]::new($values)
    }

    # BooleanValue => WS* ('True'|'False')
    hidden [MOFBooleanValue] ParseBooleanValue([ParserState]$state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)

        $matchTrue = $state.MatchLiteralText('True')
        if($null -ne $matchTrue) {
            $state.Commit()
            return [MOFBooleanValue]::new($true)
        }

        $matchFalse = $state.MatchLiteralText('False')
        if($null -ne $matchFalse) {
            $state.Commit()
            return [MOFBooleanValue]::new($false)
        }

        $state.Pop()
        return $null
    }

    # StringValue => WS* '"' StringPart? '"'
    hidden [MOFStringValue] ParseStringValue([ParserState]$state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)

        $matchStartingQuote = $state.MatchLiteralText('"')
        if($null -eq $matchStartingQuote) {
            $state.Pop()
            return $null
        }

        $result = [MOFStringValue]::new('')

        $matchStringPart = $this.ParseStringPart($state)
        if($null -ne $matchStringPart) {
            $result = $matchStringPart
        } 

        $matchStartingQuote = $state.MatchLiteralText('"')
        if($null -eq $matchStartingQuote) {
            $state.Pop()
            return $null
        }

        $state.Commit()

        return $result
    }

    # StringPart => StringPartSegment StringPart?
    hidden [MOFStringValue] ParseStringPart([ParserState]$state)
    {
        $state.Push()

        $matchStringPart = $this.ParseStringPartSegment($state)
        if($null -eq $matchStringPart) {
            $state.Pop()
            return $null
        }

        $nextStringPart = $this.ParseStringPart($state)
        if($null -ne $nextStringPart) {
            $matchStringPart.Value += $nextStringPart.Value
        }

        $state.Commit()

        return $matchStringPart
    }

    # StringPartSegment => EscapedStringPart | [^\\"]+
    hidden [MOFStringValue] ParseStringPartSegment([ParserState]$state)
    {
        $matchEscapedStringPart = $this.ParseEscapedStringPart($state)
        if($null -ne $matchEscapedStringPart) {
            return $matchEscapedStringPart
        }

        $matchStringPartExpression = $state.MatchExpression('[^\\"]+')
        if($null -ne $matchStringPartExpression) {
            return [MOFStringValue]::new(
                $matchStringPartExpression.GetText()
            )
        }

        return $null
    }

    # EscapedStringPart => '\' .
    hidden [MOFStringValue] ParseEscapedStringPart([ParserState]$state)
    {
        $state.Push()

        $matchBackslash = $state.MatchLiteralText('\')
        if($null -eq $matchBackslash) {
            $state.Pop()
            return $null
        }

        if($state.AtEnd()) {
            $state.Pop()
            return $null
        }

        $nextChar = $state.GetNextChar()

        $result = switch($nextChar) {
            'n' { "`n" }
            'r' { "`r" }
            't' { "`t" }
            'f' { "`t" }
            default { $nextChar }
        }

        # TODO : Handle more complex escape sequences... like \u001B

        $state.Commit()

        return [MOFStringValue]::new($result)
    }

    # InstanceOfAs => WS* 'as' WS+ Variable
    hidden [MOFInstanceOfAs] ParseInstanceOfAs([ParserState]$state)
    {
        $state.Push()

        $matchWs = $this.ParseWhiteSpace($state)
        if($null -eq $matchWs) {
            $state.Pop()
            return $null
        }

        $matchAs = $state.MatchLiteralText('as')
        if($null -eq $matchAs) {
            $state.Pop()
            return $null
        }

        $matchWs = $this.ParseWhiteSpace($state)
        if($null -eq $matchWs) {
            $state.Pop()
            return $null
        }

        $matchVariable = $this.ParseVariable([ParserState]$state)
        if($null -eq $matchVariable) {
            $state.Pop()
            return $null
        }

        $state.Commit()

        return [MOFInstanceOfAs]::new($matchVariable)
    }

    # Variable => WS* '\$_?([A-Za-z][A-Za-z0-9_]*)'
    hidden [MOFVariable] ParseVariable([ParserState]$state)
    {
        $state.Push()
        $this.ParseWhiteSpace($state)

        $matchVariable = $state.MatchExpression('\$_?([A-Za-z][A-Za-z0-9_]*)')
        if ($null -eq $matchVariable) {
            $state.Pop()
            return $null
        }

        $result = [MOFVariable]::new(
            $matchVariable.GetText()
        )

        $state.Commit()

        return $result
    }
    
    # LiteralName = '_?[A-Za-z][A-Za-z_]*'
    hidden [MOFLiteralName] ParseLiteralName([ParserState]$state)
    {
        $matchLiteralName = $state.MatchExpression('_?[A-Za-z][A-Za-z_]*')
        if ($null -eq $matchLiteralName) {
            return $null
        }

        $result = [MOFLiteralName]::new(
            $matchLiteralName.GetText()
        )

        return $result
    }

    # WS = '\s+'
    hidden [MOFWhiteSpace] ParseWhiteSpace([ParserState]$state)
    {
        $matchWhitespace = $state.MatchExpression('\s+')
        if ($null -ne $matchWhitespace) {
            $result = [MOFWhiteSpace]::new(
                $matchWhiteSpace.GetText()
            )

            return $result
        }

        return $null
    }

    # Comment => BlockComment
    hidden [MOFComment] ParseComment([ParserState]$state)
    {
        $parseBlockComment = $this.ParseBlockComment($state)
        if($null -ne $parseBlockComment) {
            return $parseBlockComment
        }

        return $null
    }

    # BlockComment => '\/\*(\*(?!\/)|[^*])*\*\/'
    hidden [MOFComment] ParseBlockComment([ParserState]$state)
    {
        # Attempt to match multi-line comments
        $matchComment = $state.MatchExpression('\/\*(\*(?!\/)|[^*])*\*\/')
        if ($null -ne $matchComment) {
            return [MOFComment]::new(
                $matchComment
            )
        }

        return $null
    }
}

<#
    .SYNOPSIS
        Reads the names of the DSC resource dependencies from a MOF file

    .DESCRIPTION
        Parses the MOF file provided by the MOFPath parameter and then walks the AST generated to find MOF entries
        that are instances of other types. For those instances, the values are checked for 'ModuleName' references.
        If there is a module name reference, then the name is extracted and returned. Only unique entries are returned.

    .PARAMETER MOFPath
        The path to the MOF file to read and extract DSC resources from
#>
Function Get-DSCResourceDependenciesFromMOF
{
    Param(
        [Parameter(Mandatory)]
        [string]$MOFPath
    )

    $mofText = Get-Content -Path $MOFPath

    $result = $null
    try {
        $testMOFParser = [MOFParser]::new()
        $result = $testMOFParser.Parse($mofText)
    } catch {
        #Set-Content -Path 'C:\temp\oops.mof' -Value $mofText

        throw [Exception]::new(
            'Failed to parse ' + $MOFPath,
            $_.Exception
        )
    }

    if($null -eq $result) {
        throw [Exception]::new(
            'Failed to parse ' + $MOFPath
        )
    }

    $instanceOfObjects = $result.Where{
        $_ -is [MOFInstanceOf] -and 
        ($null -ne ($_ -as [MOFInstanceOf]).As) 
    }

    if ($null -eq $instanceOfObjects) {
        return $null
    }

    $dscResourceModuleNames = $instanceOfObjects.ForEach{
        $_.Value.Values.Where{ 
            $_.Name.Name -eq 'ModuleName' -and 
            $_.Value -is [MOFStringValue] 
        }
    }.ForEach{
        $_.Value.Value
    } | Select-Object -Unique

    return $dscResourceModuleNames
}

<#
This code is written and maintained by Darren R. Starr from Conscia Norway AS.

License :

Copyright (c) 2017 Conscia Norway AS

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without limitation 
the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the Software 
is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#>

<#
    .SYNOPSIS
        Container for storing information about files to be copied from a host system to a VHD

    .DESCRIPTION
        This component is part of the MOFUtilities which can be used to copy DSC Resources in an offline
        fashion from a host computer to a .VHDX file for the purpose of making a MOF file able to run
        before network connectivity is established for a VM.
#>
class cDSCResourceManifestItem
{
    <#
        .SYNOPSIS
            A file system reference to the source file or directory item to be copied
    #>
    [System.IO.FileSystemInfo]$Item

    <#
        .SYNOPSIS
            A path to the item relative to the root of the DSC resource it belongs to
    #>
    [string]$RelativePath

    <#
        .SYNOPSIS
            The recommendation of where to copy the file relative to the root of the VHDX file
    #>
    [string]$RecommendedDestinationPath
}

<#
This code is written and maintained by Darren R. Starr from Conscia Norway AS.

License :

Copyright (c) 2017 Conscia Norway AS

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without limitation 
the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the Software 
is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#>

# TODO: Horrible hack to make sure that Get-DSCResource and all related types are available
Get-Command -Name 'Get-DSCResource' | Out-Null

<#
    .SYNOPSIS
        A class to identify and catalog information about a DSC resource locally available and where to copy it within a VHD 
        for offline installation.

    .DESCRIPTION
        cDSCResourceInformation, when provided with a DSC Resource module name identifies :
            <li>all the files that incorporate the</li>
            <li>whether the resource is a system resource (installed under system32)</li>
            <li>recommends where to copy the files (individually) relative to the root of a Windows VHD</li>

    .NOTES
        There are some oddities as to the implementation of this class. There are certain leaps of faith with regards
        to where the files are found (classifying them) and as to where to copy them (hard coded destination paths).
        Ideally, location roots would be identified via the system registry of the guest and host machines.

        This class has some groundwork implemented to identify whether the given DSC resource has any other module dependencies
        that should be able to be used to copy module dependencies as well. This has not been needed thus far, but may be needed later.
#>
class cDSCResourceInformation
{
    <#
        .SYNOPSIS
            The name of the DSC resource module
    #>
    [string]$ResourceName

    <#
        .SYNOPSIS
            The root directory of the version associated with the module
    #>
    [string]$VersionRootDirectory

    <#
        .SYNOPSIS
            The root directory of all versions of the module
    #>
    [string]$RootDirectory

    <#
        .SYNOPSIS
            The path of the PSD1 file within the module
    #>
    [string]$PSD1Path

    <#
        .SYNOPSIS
            Ther version number of the resource as reported by Get-DSCResource
    #>
    [string]$ResourceVersion

    <#
        .SYNOPSIS
            Is the module located in the System32 directory?
    #>
    [bool]$SystemModule

    <#
        .SYNOPSIS
            A manifest of files and directories to be copied to the VHD file. Recommended destination paths are also included.
    #>
    [cDSCResourceManifestItem[]]$Manifest

    <#
        .SYNOPSIS
            The destination root path of modules to be located under System32
    #>
    hidden static [string]$SystemModulePath = '\Windows\System32\WindowsPowerShell\v1.0\Modules'

    <#
        .SYNOPSIS
            The destination root path of modules to be located under program files
    #>
    hidden static [string]$ProgramFilesModulePath = '\Program Files\WindowsPowerShell\Modules'

    <#
        .SYNOPSIS
            The local system path for where System32 rooted modules should be found
    #>
    hidden static [string]$HostSystemModulePath = [cDSCResourceInformation]::GetExactPathName((Join-Path -Path $Env:windir -ChildPath 'System32\WindowsPowershell\v1.0\Modules'))

    <#
        .SYNOPSIS
            The local system path for where Program Files rooted modules should be found
    #>
    hidden static [string]$HostProgramFileModulePath = [cDSCResourceInformation]::GetExactPathName((Join-Path -Path $Env:ProgramFiles -ChildPath 'WindowsPowershell\Modules'))

    <#
        .SYNOPSIS
            Constructor and worker

        .DESCRIPTION
            The constructor queries the system for all pertainant information regarding the provided module name. It then makes
            a list of all the files within the module and calculated recommended destination paths for each item.
    #>
    cDSCResourceInformation([string]$name)
    {
        $this.ResourceName = $name

        # Find information about the resource from the system
        Write-Verbose -Message ('Calling Get-DscResource for module ' + $name)
        $resource = Get-DscResource -Module $name -Verbose:$false | Where-Object { $_.ModuleName -eq $Name } | Select-Object -Unique
        if($null -eq $resource) {
            throw [System.Exception]::new(
                'Invalid module name passed'
            )
        }

        if([string]::IsNullOrEmpty($resource.Path)) {
            throw [System.Exception]::new(
                'Cannot identify the path of where to find DSC resource [' + $name + ']'
            )
        }

        # Gather directory information
        $this.ResourceVersion = $resource.Version
        Write-Verbose -Message ('Resource version = ' + $this.ResourceVersion)

        $this.PSD1Path = $this.FindDSCResourcePSD1($resource.Path)
        Write-Verbose -Message ('PSD1 file = ' + $this.PSD1Path)

        $this.VersionRootDirectory = $this.GetDSCResourceVersionRootDirectory($this.PSD1Path)
        Write-Verbose -Message ('Version root directory = ' + $this.VersionRootDirectory)
        
        $this.RootDirectory = $this.GetDSCResourceRoot($this.VersionRootDirectory, $this.ResourceVersion)
        Write-Verbose -Message ('Resource root directory = ' + $this.RootDirectory)

        # Identify whether this is a system module (under System32)
        $this.SystemModule = [cDSCResourceInformation]::IsWindowsSystemModule($this.RootDirectory)
        Write-Verbose -Message ('Is system resource? ' + $this.SystemModule.ToString())

        # Catalog all files in the resource and produce a manifest for the copy operation.
        $dscResourceItems = Get-ChildItem -Path $this.VersionRootDirectory -Recurse
        $this.Manifest = $dscResourceItems.foreach{ 
            $relativePath = [cDSCResourceInformation]::GetRelativePath($this.VersionRootDirectory, $_.FullName)

            [cDSCResourceManifestItem] @{
                Item = $_
                RelativePath = $relativePath
                RecommendedDestinationPath = $this.GetRecommendedDestinationPath($relativePath)
            }
        }
    }

    <#
        .SYNOPSIS
            Overload of ToString() to make debugging easier
    #>
    [string]ToString()
    {
        return $this.ResourceName + ', ' + $this.ResourceVersion + ', ' + $this.RootDirectory + ', System?=' + $this.SystemModule.ToString()
    }

    <#
        .SYNOPSIS
            Checks to see whether the given path is rooted beneath %WINDIR%\System32
    #>
    hidden static [bool] IsWindowsSystemModule([string]$path)
    {
        return $path.StartsWith([cDSCResourceInformation]::HostSystemModulePath)
    }

    <#
        .SYNOPSIS
            Provides a recommendation for where to copy a file within a VHD file

        .DESCRIPTION
            For system modules, \Windows\System32\WindowsPowerShell\v1.0\Modules is used

            For non-system modules, \Program Files\WindowsPowerShell\Modules\{ResourceName}\{ResourceVersion} is used
    #>
    hidden [string] GetRecommendedDestinationPath([string]$RelativePath)
    {
        if($this.SystemModule) {
            return [System.IO.Path]::Combine([cDSCResourceInformation]::SystemModulePath)
        }

        return [System.IO.Path]::Combine(
            [System.IO.Path]::Combine([cDSCResourceInformation]::ProgramFilesModulePath, $this.ResourceName),
            $this.ResourceVersion
        )
    }

    <#
        .SYNOPSIS
            Returns the relative path from a base file path to a child file path.

        .NOTES
            This code may not be 100% Powershell Core friendly
    #>
    static hidden [string] GetRelativePath([string]$BasePath, [string]$ChildPath)
    {
        if(-not $BasePath.EndsWith('\')) {
            $BasePath += '\'
        }
            
        $basePathURI = [System.Uri]::new($BasePath)
        $childPathURI = [System.Uri]::new($ChildPath)

        $relativeUri = $basePathURI.MakeRelativeUri($childPathURI)

        return $relativeUri.ToString().Replace('/', '\')
    }

    <#
        .SYNOPSIS
            Given a full path name, resolves with correct case sensetivity of the path as is seen on the filesystem itself

        .NOTES
            This code was necessary because [System.IO.FileSystemInfo]::FullName does not resolve and correct paths
    #>
    static hidden [string] GetExactPathName([string]$PathName) 
    {
        if (-not (Test-Path -Path $PathName)) {
            return $PathName
        }

        $di = [System.IO.DirectoryInfo]::new($PathName)
        if ($null -ne $di.Parent) {
            return [System.IO.Path]::Combine(
                [cDSCResourceInformation]::GetExactPathName($di.Parent.FullName),
                $di.Parent.GetFileSystemInfos($di.Name)[0].Name
            )
        } else {
            return $di.Name.ToUpper()
        }
    }

    <#
        .SYNOPSIS
            From a given file or directory path, traverses the file path and locates a .PSD1 file to correlate to the module
    #>
    hidden [string] FindDSCResourcePSD1([string]$ResourcePath)
    {
        if(-not (Test-Path -Path $ResourcePath)) {
            throw [System.IO.FileNotFoundException](
                'Failed to find file',
                $ResourcePath
            )
        }

        Write-Verbose -Message ('Getting file system info for ' + $ResourcePath)
        $fi = [System.IO.FileInfo]::new($ResourcePath)
        if($fi.Extension.ToLower() -eq '.psd1') {
            return $ResourcePath
        }

        $resultPath = $fi.Directory.FullName
        while(-not [String]::IsNullOrEmpty($resultPath)) {
            $fi = [System.IO.FileInfo]::new($resultPath)

            Write-Verbose -Message ('Getting PSD1 files for ' + $fi.Directory.FullName)
            $psd1Files = $fi.Directory.GetFiles($this.ResourceName + '.psd1')
            if($null -ne $psd1Files) {
                if($psd1Files.Count -eq 1) {
                    return [cDSCResourceInformation]::GetExactPathName($psd1Files[0].FullName)
                }
            }

            $resultPath = $fi.Directory.FullName
        }

        if([String]::IsNullOrEmpty($resultPath)) {
            throw [System.Exception]::new(
                'Unhandled case, module ' + $this.ResourceName + ' is lacking a PSD1 file with the name [' + $this.ResourceName + '.psd1' 
            )
        }

        return [cDSCResourceInformation]::GetExactPathName($resultPath)
    }

    <#
        .SYNOPSIS
            Identifies the root path of a DSC resource from the path which contains the .PSD1 file

        .NOTES
            With Windows PowerShell 5 side-by-side module versioning, it is necessary to sometimes
            traverse upwards an additional level from where the .PSD1 is found
    #>
    hidden [string] GetDSCResourceRoot([string]$VersionRoot, [string]$Version)
    {
        if(-not (Test-Path -Path $VersionRoot -PathType Container)) {
            throw [System.IO.DirectoryNotFoundException]::new(
                'DSC Resource VersionRoot is not present'
            )
        }

        $di = [System.IO.DirectoryInfo]::new($VersionRoot)
        if($di.BaseName -eq $Version) {
            return [cDSCResourceInformation]::GetExactPathName($di.Parent.FullName)
        }

        return $VersionRoot
    }

    <#
        .SYNOPSIS
            Returns the directory containing the .PSD1 file for the given resource path.

        .NOTES
            TODO: This should be altered to use the PSD1 path instead of the resource path as the
            input variable
    #>
    hidden [string] GetDSCResourceVersionRootDirectory([string]$ResourcePath)
    {
        if(-not [String]::IsNullOrEmpty($ResourcePath)) {
            $psdPath = $this.FindDSCResourcePSD1($ResourcePath)
                        
            $fi = [System.IO.FileInfo]::new($psdPath)

            return $fi.Directory.FullName
        }

        return $null
    }

    <#
        .SYNOPSIS
            Reads the contents of a mpdule's PSD1 to identofy whether any other modules are listed as
            dependencies to this resource.
    #>
    hidden [string[]] GetResourceModuleDependencies([string]$PSD1Path)
    {
        $psdContent = Get-Content -Path $PSD1Path -raw
        $psd = Invoke-Expression -Command $psdContent
        return $psd.PSDModules
    }
}

<#
This code is written and maintained by Darren R. Starr from Conscia Norway AS.

License :

Copyright (c) 2017 Conscia Norway AS

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without limitation 
the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the Software 
is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#>

<#
    .SYNOPSIS
        A class to perform an offline installation of DSC resources needed by a MOF file

    .DESCRIPTION
        This class opens, parses and extracts a list of all DSC resource dependencies needed by
        a MOF file. Then it catalogs a manifest of all the files and directories needed for the
        DSC resources and copies them to a location, assumed to be the root directory of a mounted
        Windows Server VHD based virtual machine to the directory structure of that virtual machine.

  .AUTHOR
      Darren R. Starr
 
  .COPYRIGHT
      2017 Conscia Norway AS
 
    .NOTES
        I am not 1000% percent secure in my means of identifying the root of a DSC resource as
        there is no mechanism I could find on Get-DSCResource to return the GUID of the resource
        so I could read the contents of a PSD1 file and match it to the resource module.
#>
class cOfflineMOFDependencyInstaller
{
    <#
        .SYNOPSIS
            Read the contents of a MOF file and return DSC resource dependencies
    #>
    static hidden [string[]] GetDSCResourceDependenciesFromMOF([string]$MOFPath)
    {
        if(-not (Test-Path -Path $MOFPath)) {
            throw [System.IO.FileNotFoundException]::new(
                'MOF file [' + $MOFPath + '] not found'
            )
        }

        # Read the contents of the MOF file
        $mofText = Get-Content -Path $MOFPath

        # Attempt to parse the MOF file
        $result = $null
        try {
            $testMOFParser = [MOFParser]::new()
            $result = $testMOFParser.Parse($mofText)
        } catch {
            throw [Exception]::new(
                'Failed to parse ' + $MOFPath,
                $_.Exception
            )
        }

        # Throw an exception if there was no result
        if($null -eq $result) {
            throw [Exception]::new(
                'Failed to parse ' + $MOFPath
            )
        }

        # Find MOF objects which contain 'As' clauses
        $instanceOfObjects = $result.Where{
            $_ -is [MOFInstanceOf] -and 
            ($null -ne ($_ -as [MOFInstanceOf]).As) 
        }

        if ($null -eq $instanceOfObjects) {
            return $null
        }

        # Find the names of the module dependencies when inheriting using 'As'
        $dscResourceModuleNames = $instanceOfObjects.ForEach{
            $_.Value.Values.Where{ 
                $_.Name.Name -eq 'ModuleName' -and 
                $_.Value -is [MOFStringValue] 
            }
        }.ForEach{
            $_.Value.Value
        } | Select-Object -Unique

        return $dscResourceModuleNames
    }

    static [void]CopyMOFDependencies([string]$MOFPath, [string]$WindowsVHDRoot)
    {
        $dscResourceDependencies = [cOfflineMOFDependencyInstaller]::GetDSCResourceDependenciesFromMOF($MOFPath)
        Write-Verbose -Message ('Identified ' + $dscResourceDependencies.Count.ToString() + ' resource dependencies')
        $dscResourceDependencies.ForEach{ 
            Write-Verbose -Message ('Dependency - ' + $_)
        }

        $resources = $null
        try {
            $resources = $dscResourceDependencies.ForEach{ [cDSCResourceInformation]::new($_) }        
        } catch {
            Write-Verbose -Message ('Failed to get resource information for ' + $_)
            throw $_.Exception
        }
    
        $resources.ForEach{ 
            Write-Host $_

            $_.Manifest.ForEach{
                $destinationPath = Join-Path -Path $WindowsVHDRoot -ChildPath $_.RecommendedDestinationPath
                if(-not (Test-Path -Path $destinationPath)) {
                    Write-Verbose -Message ('  Creating - [' + $destinationPath + ']')
                    New-Item -Path $destinationPath -ItemType Directory
                }

                $itemDestinationPath = Join-Path -Path $destinationPath -ChildPath $_.RelativePath
                if($_.Item -is [System.IO.DirectoryInfo]) {
                    if(-not (Test-Path -Path $itemDestinationPath)) {
                        Write-Verbose ('  Creating - [' + $itemDestinationPath + ']')
                        New-Item -Path $itemDestinationPath -ItemType Directory
                    }
                } elseif($_.Item -is [System.IO.FileInfo]) {
                    if(-not (Test-Path -Path $itemDestinationPath)) {
                        Write-Verbose -Message ('    Copying - [' + $_.item.FullName + '] to [' + $itemDestinationPath + ']')
                        Copy-Item -Path $_.item.FullName -Destination $itemDestinationPath 
                    }
                } else {
                    throw [System.Exception]::new(
                        'Cannot process unknown file system type - ' + $_.Item.FullName
                    )
                }
            } 
        }
    }
}

<#
This code is written and maintained by Darren R. Starr from Conscia Norway AS.

License :

Copyright (c) 2017 Conscia Norway AS

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without limitation 
the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the Software 
is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#>

<# 
    .SYNOPSIS
        A resource for copying files into the contents of a VHD file
#>
[DscResource()]
class cVHDFileSystem 
{
    [DscProperty(Key)]
    [string] $VHDPath

    [DSCProperty()]
    [bool] $OkIfMounted = $true

    [DSCProperty()]
    [UInt64] $OkIfOverBytes = 4MB

    [DSCProperty(Mandatory)]
    [string[]] $ItemList

    [DSCProperty()]
    [string] $InitialMOF

    [DSCProperty()]
    [string] $MOFPath

    <#
        .SYNOPSIS
            Resource Get
    #>
    [cVHDFileSystem] Get()
    {
        [cVHDFileSystem]$result = [cVHDFileSystem]::new()

        $result.VHDPath = $this.VHDPath

        return $result
    }

    <#
        .SYNOPSIS
            Resource Test
    #>
    [bool] Test()
    {
        Write-Verbose -Message ('Testing for presence of [' + $this.VHDPath +'])')
        if (-not (Test-Path -Path $this.VHDPath)) {
            Write-Verbose -Message('VHD File [' + $this.VHDPath + '] not present')
            return $false
        }

        if($this.OkIfOverBytes -gt 0) {
            Write-Verbose -Message ('OkIfOverBytes is ' + $this.OkIfOverBytes + ' bytes. Testing file size')
            $fileItem = Get-Item -Path $this.VHDPath

            if($null -eq $fileItem) {
                throw [System.Exception]::new(
                    'Failed to call Get-Item on ' + $this.VHDPath
                )
            }

            Write-Verbose ('File size is ' + $fileItem.Length.ToString() + ' bytes')
            if($fileItem.Length -gt $this.OkIfOverBytes) {
                Write-Verbose -Message 'Test condition met'
                return $true
            }

            return $false
        }

        Write-Verbose -Message ('Getting mounted information about VHD')
        try {
            $MountedDiskImage = Get-WmiObject -Namespace 'root\virtualization\v2' -query "SELECT * FROM MSVM_MountedStorageImage WHERE Name ='$($this.VHDPath.Replace("\", "\\"))'"

            if($null -ne $MountedDiskImage) {
                If($this.OkIfMounted) {
                    Write-Verbose -Message ('[' + $this.VHDPath + '], VHD is already mounted and OkIfMounted is $true, test is ok')
                    return $true
                }

                throw [System.Exception]::new(
                    '[' + $this.VHDPath + '], VHD is already mounted and cannot be altered in its current state'
                )
            }
        } catch {
            if($_.Exception.Message.StartsWith('[')) {
                throw $_.Exception
            }

            throw [System.Exception]::new(
                'Failed to get information from virtualization root regarding mounted images',
                $_.Exception
            )
        }

        # TODO : Add code to test contents of VHD against file list

        return $true
    }

    <#
        .SYNOPSIS
            Resource Set
    #>
    [void] Set()
    {
        Write-Verbose -Message ('Testing for presence of [' + $this.VHDPath +'])')
        if (-not (Test-Path -Path $this.VHDPath)) {
            throw [System.IO.FileNotFoundException]::new(
                'VHD File not present',
                $this.VHDPath
            )
        }

        Write-Verbose -Message ('Checking initial validity of item list')
        if($null -eq $this.ItemList) {
            throw [System.ArgumentNullException]::new(
                'No item list was passed',
                'ItemList'
            )
        }

        if((($this.ItemList.Count % 2) -eq 1) -or ($this.ItemList.Count -eq 0)) {
            throw [System.ArgumentException]::new(
                'ItemList must be formatted as a list of strings of source path and destination path.',
                'ItemList'
            )
        }

        if((-not [string]::IsNullOrEmpty($this.InitialMOF))) {
            if (-not (Test-Path -Path $this.InitialMOF)) {
                throw [System.IO.FileNotFoundException]::new(
                    'Initial MOF file is specified but can''t be found [' + $this.InitialMOF + ']',
                    'InitialMOF'
                )
            }

            if ([string]::IsNullOrEmpty($this.MOFPath)) {
                throw [System.ArgumentException]::new(
                    'Initial MOF file is specified, but there is no destination to copy it to specified',
                    'InitialMOF'
                )
            }

            Write-Verbose -Message ('InitialMOF = [' + $this.InitialMOF + '], MOFPath = [' + $this.MOFPath + ']')
        }

        Write-Verbose -Message ('ItemList meets preliminary checks')

        $this.MountVHDImage()

        try {
            $this.CopyItems()
            $this.CopyInitialMOFAndDependencies()
        } catch {
            Write-Verbose -Message $_.Exception.Message
            throw [System.Exception]::new(
                'File copy operation failed',
                $_.Exception                
            )
        } finally {
            $this.DismountVHDImage()
        }
    }

    hidden static [string]$GptTypeUEFISystem = '{c12a7328-f81f-11d2-ba4b-00a0c93ec93b}'
    hidden static [string]$GptTypeMicrosoftReserved = '{e3c9e316-0b5c-4db8-817d-f92df00215ae}'
    hidden static [string]$GptTypeMicrosoftBasic = '{ebd0a0a2-b9e5-4433-87c0-68b6b72699c7}'

    hidden [string] $WindowsPartitionRoot

    # TODO : Should be static
    hidden [string]$PushLCMConfig = 
@'
[DSCLocalConfigurationManager()]
Configuration LCMConfig
{
    Node localhost { 
        Settings {
            RefreshMode='Push'
            RebootNodeIfNeeded=$true
            ActionAfterReboot='ContinueConfiguration'
        }
    }
}
LCMConfig -OutputPath 'c:\Windows\Panther\lcmmof'
Set-DscLocalConfigurationManager -Path 'c:\Windows\Panther\lcmmof' -ComputerName 'localhost'
'@ 

    hidden [void] WritePushLCMConfig()
    {
        $pantherScriptPath = Join-Path -Path $this.WindowsPartitionRoot -ChildPath 'Windows\Panther\Scripts'
        Write-Verbose -Message ('Testing for presence of [' + $pantherScriptPath + ']')
        if(-not (Test-Path -Path $pantherScriptPath)) {
            Write-Verbose -Message ('Creating [' + $pantherScriptPath + ']')
            New-Item -Path $pantherScriptPath -ItemType Directory
        }

        Write-Verbose -Message 'Writing LCMSetPushLocal.ps1'
        $lcmConfigScriptPath = Join-Path -Path $pantherScriptPath -ChildPath 'LCMSetPushLocal.ps1'
        Set-Content -Path $lcmConfigScriptPath -Value $this.PushLCMConfig
    }

    hidden [void] CopyInitialMOFAndDependencies()
    {
        if([string]::IsNullOrEmpty($this.InitialMOF)) {
            Write-Verbose -Message 'No initial MOF specified'
            return
        }

        $fullMofPath = Join-Path -Path $this.WindowsPartitionRoot -ChildPath $this.MOFPath

        Write-Verbose -Message ('Checking for presence of MOF destination path [' + $fullMofPath + ']')
        if(-not (Test-Path -Path $fullMofPath)) {
            Write-Verbose -Message ('Creating [' + $fullMofPath + ']')
            New-Item -Path $fullMofPath -ItemType Directory
        }

        $fi = [System.IO.FileInfo]::new($this.InitialMOF)
        $initialMofDestination = Join-Path -Path $fullMofPath -ChildPath $fi.Name

        Write-Verbose -Message ('Copying [' + $this.InitialMOF + '] to [' + $initialMofDestination + ']')
        Copy-Item -Path $this.InitialMOF -Destination $initialMofDestination -Force

        Write-Verbose -Message ('Copying MOF DSC Resource Dependencies')
        [cOfflineMOFDependencyInstaller]::CopyMOFDependencies($this.InitialMOF, $this.WindowsPartitionRoot)

        $this.WritePushLCMConfig()
    }

    [void] CopyItems()
    {
        Write-Verbose -Message ('Refreshing PS Drive list')
        Get-PSDrive

        $itemCount = $this.ItemList.Count

        for($i = 0; $i -lt $itemCount; $i += 2) {
            $sourceItem = $this.ItemList[$i]
            $destinationItem = $this.ItemList[$i + 1]

            Write-Verbose -Message ('SourcePath = [' + $sourceItem + '], DestinationPath = [' + $destinationItem + ']')
            
            Write-Verbose -Message ('Verifying presence of source file [' + $sourceItem + ']')
            if(-not (Test-Path -Path $sourceItem)) {
                throw [System.IO.FileNotFoundException]::new(
                    'Source item not found',
                    $sourceItem
                )
            }

            $destinationPath = Join-Path -Path $this.WindowsPartitionRoot -ChildPath $destinationItem
            Write-Verbose -Message ('Checking for presence of destination file [' + $destinationPath + ']')
            if(Test-Path -Path $destinationItem) {
                throw [System.Exception]::new(
                    'Overwriting existing files is not currently supported [' + $destinationItem + ']'
                )
            }

            Write-Verbose -Message ('Constructing parent path name for [' + $destinationPath + ']')
            $destinationFileInfo = [System.IO.FileInfo]::new($destinationPath)
            $destinationParent = $destinationFileInfo.Directory.FullName

            Write-Verbose -Message ('Checking for parent directory of destination file [' + $destinationParent + ']')
            if (-not (Test-Path -Path $destinationParent)) {
                throw [System.IO.DirectoryNotFoundException]::new(
                    'Parent directory of destination item does not exist and force creation is not supported yet',
                    $destinationParent
                )
            }

            Write-Verbose -Message 'Parent directory exists, preparing to copy'

            $sourceFileItem = Get-Item -Path $sourceItem
            if ($sourceFileItem.GetType().Name -eq 'DirectoryInfo') {
                Write-Verbose -Message 'Source item is a directory'
                Copy-Item -Path $sourceItem -Destination $destinationPath -Recurse -Confirm:$false -Force
            } elseif ($sourceFileItem.GetType().Name -eq 'FileInfo') {
                Write-Verbose -Message 'Source item is a normal file'
                Copy-Item -Path $sourceItem -Destination $destinationPath -Confirm:$false -Force
            } else {
                Write-Verbose -Message 'WTF'
                throw [System.Exception]::new(
                    '[' + $sourceItem + '] is an unsupported type [' + $sourceFileItem.GetType() + ']'
                )
            }
        }
    }

    [void] MountVHDImage()
    {
        $vhd = $null
        try {
            Write-Verbose -Message ('Getting handle to the VHD file')
            $vhd = Get-Vhd -Path $this.VHDPath 
            if($null -eq $vhd) {
                throw [System.Exception]::new(
                    'Unknown error getting handle to the vhd'
                )
            }
        } catch {
            if($_.Exception.Message.BeginsWith('Unknown')) {
                throw $_.Exception
            }

            throw [System.Exception]::new(
                'Error obtaining VHD handle to ' + $this.VHDPath,
                $_.Exception
            )
        }

        $mountResult = $null
        try {
            Write-Verbose -Message ('Obtained VHD Handle, mounting VHD image')
            $mountResult = $vhd | Mount-VHD -Passthru
            if ($null -eq $mountResult) {
                throw [System.Exception]::new(
                    'Unknown error mounting VHD [' + $this.VHDPath + ']'
                )
            }
        } catch {
            if($_.Exception.Message.BeginsWith('Unknown')) {
                throw $_.Exception
            }

            throw [System.Exception]::new(
                'Error mounting VHD ' + $this.VHDPath,
                $_.Exception
            )            
        }

        try {
            Write-Verbose -Message 'Mounted VHD, getting windows disk handle'

            $disk = $mountResult | Get-Disk
            if ($null -eq $disk) {
                throw [System.Exception]::new(
                    'Failed to get disk handle'
                )
            }

            Write-Verbose -Message 'Obtained windows disk handle, getting partition table'

            $partitions = $disk | Get-Partition
            if ($null -eq $partitions) {
                throw [System.Exception]::new(
                    'Failed to get partition table'
                )
            }

            # TODO : Consider calling BCDBOOT to read the boot information for the drive.
            # TODO : Consider simply getting an NTFS partition with a drive letter assigned

            $windowsPartition = $null
            try {
                Write-Verbose -Message 'Obtained partition table, searching for first non-system and non-UEFI partition which has an assigned drive letter'
                $windowsPartition = $partitions | Where-Object { 
                    ($_.GptType -ne [cVhdFileSystem]::GptTypeUEFISystem) -and 
                    ($_.GptType -ne [cVhdFileSystem]::GptTypeMicrosoftReserved) -and 
                    ([char]::IsLetter($_.DriveLetter[0])) 
                }
            } catch {
                throw [System.Exception]::new(
                    'Failed to get a partition meeting the criteria of a Windows boot drive',
                    $_.Exception
                )
            }

            if ($null -eq $windowsPartition) {
                #TODO : Generate error if there is more than one item returned.
                throw [System.Exception]::new(
                    'Failed to find a non-UEFI or Reserved partition'
                )
            }

            Write-Verbose -Message ('Windows partition found, resolving drive letter')
            $this.WindowsPartitionRoot = $windowsPartition.DriveLetter + ':\'
            Write-Verbose -Message ('Windows drive root is ' + $this.WindowsPartitionRoot)

            try {
                Write-Verbose -Message ('Making drive root accessible to other commandlets')
                $psDrive = New-PSDrive -Name $windowsPartition.DriveLetter -PSProvider FileSystem -Root $this.WindowsPartitionRoot 
                if ($null -eq $psDrive) {
                    throw [System.Exception]::new(
                        'Unknown error when trying to make drive accessible to other commandlets'
                    )
                }
            } catch {
                if ($_.Exception.Message.BeginsWith('Unknown')) {
                    throw $_.Exception
                }

                throw [System.Exception]::new(
                    'Failed to make drive accessible to other commandlets',
                    $_.Exception
                )
            }

            Write-Verbose -Message ('Drive root now accessible to other commandlets')
        } catch {
            Write-Error -Message ('Failed to complete mounting system drive of [' + $this.VHDPath + '] dismounting image')

            try {
                $vhd | Dismount-VHD 
            } catch {
                Write-Error -Message ('Failed to unmount VHD')
            }

            $this.WindowsPartitionRoot = $null

            throw [System.Exception]::new(
                'Failed to complete mounting and making [' + $this.VHDPath + '] accessible to other commandslet',
                $_.Exception
            )
        } 
    }

    [void] DismountVHDImage()
    {
        $vhd = $null
        try {
            Write-Verbose -Message ('Getting handle to the VHD file')
            $vhd = Get-Vhd -Path $this.VHDPath 
            if($null -eq $vhd) {
                throw [System.Exception]::new(
                    'Unknown error getting handle to the vhd'
                )
            }
        } catch {
            if($_.Exception.Message.BeginsWith('Unknown')) {
                throw $_.Exception
            }

            throw [System.Exception]::new(
                'Error obtaining VHD handle to ' + $this.VHDPath,
                $_.Exception
            )
        }

        try {
            Write-Verbose -Message 'Dismounting VHD'
            $vhd | Dismount-VHD
        } catch {
            throw [System.Exception]::new(
                'Failed to dismount [' + $this.VHDPath + ']',
                $_.Exception
            )
        }
    }
}

