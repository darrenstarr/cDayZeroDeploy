# ---------------------------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE - THIS IS A GENERATED FILE
# ------
# This file is generated by HelperScripts/buildPSM.ps1 by combining the source files from the project
# into this one script.
# ---------------------------------------------------------------------------------------------------
<#
This code is written and maintained by Darren R. Starr from Conscia Norway AS.

License :

Copyright (c) 2017 Conscia Norway AS

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without limitation 
the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the Software 
is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#>

enum PresentState {
    Present
    Absent
}

<# 
    .SYNOPSIS
        A resource for managing NAT rules for IPv4 networking
#>
[DscResource()]
class cNATRule
{
    [DscProperty(Key)]    
    [string] $Name

    [DscProperty()]
    [PresentState] $Ensure = [PresentState]::Present

    [DscProperty()]
    [bool] $Active = $true

    [DscProperty()]
    [string] $InternalIPInterfaceAddressPrefix

    [cNATRule] Get()
    {
        $result = [cNATRule] @{
            Name = $this.Name
        }

        $natRule = Get-NetNat -Name $this.Name

        if($null -eq $natRule) {
            $result.Ensure = [PresentState]::Absent
        } else {
            $result.Ensure = [PresentState]::Present
            $result.Active = $natRule.Active
            $result.InternalIPInterfaceAddressPrefix = $natRule.InternalIPInterfaceAddressPrefix
        }

        return $result
    }

    [void] Set()
    {
        if($this.Test()) {
            return
        }

        Write-Verbose -Message ('Getting existing NAT rule if present')
        $natRule = Get-NetNat -Name $this.Name
        
        if($this.Ensure -eq [PresentState]::Absent) {
            if($null -ne $natRule) {
                Write-Verbose -Message ('Removing NAT rule')
                $natRule | Remove-NetNat -Confirm:$false
            } else {
                Write-Verbose -Message ('Nothing to do')
            }
        } else {
            if($null -eq $natRule) {
                Write-Verbose -Message ('Creating new NAT rule')
                New-NetNat -Name $this.Name -InternalIPInterfaceAddressPrefix $this.InternalIPInterfaceAddressPrefix
            } else {
                Write-Verbose -Message ('Updating existing NAT rule')
                $natRule | Remove-NetNat -Confirm:$false
                New-NetNat -Name $this.Name -InternalIPInterfaceAddressPrefix $this.InternalIPInterfaceAddressPrefix
            }
        } 

        if(-not $this.Test()) {
            throw [Exception]::new(
                'Failed for unknown reason'
            )
        }
    }

    [bool] Test()
    {
        $currentState = $this.Get()

        if ($this.Ensure -ne $currentState.Ensure) {
            return $false
        }

        if($this.Ensure -eq [PresentState]::Present) {
            return (
                ($this.InternalIPInterfaceAddressPrefix -eq $currentState.InternalIPInterfaceAddressPrefix) -and
                ($this.Active -eq $currentState.Active)
            )
        }

        return $true 
    }
}
<#
This code is written and maintained by Darren R. Starr from Nocturnal Holdings AS Norway.

License :

Copyright (c) 2016 Nocturnal Holdings AS Norway

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without limitation 
the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the Software 
is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#>

<# 
    .SYNOPSIS
        Values of WillReboot for the section RunSynchronousCommand within unattend.xml

    .LINK
        https://technet.microsoft.com/en-us/library/cc722061(v=ws.10).aspx
#>
enum EnumWillReboot {
    Always
    OnRequest 
    Never
}

<#
    .SYNOPSIS
        Valid values for authentication types for remote desktop login

    .LINK
        https://technet.microsoft.com/en-us/library/cc722192(v=ws.10).aspx
#>
enum EnumRdpAuthentication {
    NetworkLevel = 0
    UserLevel = 1
}

<#
    .SYNOPSIS 
        An API for generating Unattend.xml files for Windows Server 2016

    .DESCRIPTION
        UnattendXML is a class designed for generating "properly formatted" XML
        that meets the schema requirements of Microsoft's Windows Server 2016 unattend.xml
        format.

        The code is written as a flat class instead of a serialized data structure as the 
        excessive additional complexity one would expect from serialization would be 
        overwhelming to implement.

        Given the current state of the class, it is only implemented as much as necessary
        to perform the operations the author of the class needed. As comments, needs and 
        suggestions as well as patches increase, the functionality of the class will increase.

        The current design risks a namespace clutter and possibily even constraints due to its
        flat but easy to use nature.

    .EXAMPLE
        using module UnattendXML.psm1

        $unattend = [UnattendXml]::new()
        $unattend.SetComputerName('BobsPC')
        $unattend.SetRegisteredOwner('Bob Minion')
        $unattend.SetRegisteredOrganization('Minions Evil Empire')
        $unattend.SetTimeZone('W. Europe Standard Time')
        $unattend.SetAdministratorPassword('C1sco12345')
        $unattend.SetInterfaceIPAddress('Ethernet', '10.1.1.5', 24, '10.1.1.1')
        $unattend.SetDHCPEnabled('Ethernet', $false)
        $unattend.SetRouterDiscoveryEnabled('Ethernet', $false)
        $unattend.SetInterfaceIPv4Metric('Ethernet', 10)
        $outputXML = $unattend.ToXml()
#>
class UnattendXml 
{
    hidden [Xml]$document = (New-Object -TypeName Xml)
    hidden [System.Xml.XmlElement]$XmlUnattended

    hidden static [string] $XmlNs = 'urn:schemas-microsoft-com:unattend'
    hidden static [string] $ProcessorArchitecture='amd64'
    hidden static [string] $VersionScope='nonSxS'
    hidden static [string] $LanguageNeutral='neutral'
    hidden static [string] $WCM = 'http://schemas.microsoft.com/WMIConfig/2002/State'
    hidden static [string] $XmlSchemaInstance = 'http://www.w3.org/2001/XMLSchema-instance'

    static hidden [string] WillRebootToString([EnumWillReboot]$Value)
    {
        if($Value -eq [EnumWillReboot]::Always) { return 'Always' }
        if($Value -eq [EnumWillReboot]::Never) { return 'Never' }
        if($Value -eq [EnumWillReboot]::OnRequest) { return 'OnRequest' }
        throw 'Invalid value for WillReboot'
    }

    static hidden [string] RdpAuthenticationModeToString([EnumRdpAuthentication]$Value)
    {
        if($Value -eq [EnumRdpAuthentication]::NetworkLevel) { return 0 }
        if($Value -eq [EnumRdpAuthentication]::UserLevel) { return 1 }
        throw 'Invalid value for RDP authentication mode'
    }

    hidden [System.Xml.XmlElement] GetSettingsNode([string]$Pass)
    {
        # TODO : Should this be -eq $Pass?
        $result = $this.XmlUnattended.ChildNodes | Where-Object { $_.Name -eq 'Settings' -and $_.Attributes['pass'].'#text' -like $Pass }
        If ($result -eq $null) {
            $result = $this.document.CreateElement('settings', $this.document.DocumentElement.NamespaceURI)
            $result.SetAttribute('pass', $Pass)
            $this.XmlUnattended.AppendChild($result) | Out-Null
        } 

        return $result
    }

    hidden [System.Xml.XmlElement] GetOfflineServicingSettings()
    {
        return $this.GetSettingsNode('offlineServicing')
    }

    hidden [System.Xml.XmlElement] GetSpecializeSettings()
    {
        return $this.GetSettingsNode('specialize')
    }    

    hidden [System.Xml.XmlElement] GetOobeSystemSettings()
    {
        return $this.GetSettingsNode('oobeSystem')
    }

    hidden [System.Xml.XmlElement] GetSectionFromSettings([System.Xml.XmlElement]$XmlSettings, [string]$Name)
    {
        $result = $XmlSettings.ChildNodes | Where-Object { $_.LocalName -eq 'component' -and $_.Attributes['name'].'#text' -eq $Name }
        if ($result -eq $null)
        {
            $result = $this.document.CreateElement('component', $this.document.DocumentElement.NamespaceURI)
            $result.SetAttribute('name', $Name)
            $result.SetAttribute('processorArchitecture', [UnattendXml]::ProcessorArchitecture)
            $result.SetAttribute('publicKeyToken', '31bf3856ad364e35')
            $result.SetAttribute('language', [UnattendXml]::LanguageNeutral)
            $result.SetAttribute('versionScope', [UnattendXml]::VersionScope)
            $result.SetAttribute('xmlns:wcm', [UnattendXml]::WCM)
            $result.SetAttribute('xmlns:xsi', [UnattendXml]::XmlSchemaInstance)

            $XmlSettings.AppendChild($result) | Out-Null
        }

        return $result
    }

    hidden [System.Xml.XmlElement] GetWindowsShellSetupSection([System.Xml.XmlElement]$XmlSettings)
    {
        return $this.GetSectionFromSettings($XmlSettings, 'Microsoft-Windows-Shell-Setup')
    }

    hidden [System.Xml.XmlElement] GetTerminalServicesLocalSessionManager([System.Xml.XmlElement]$XmlSettings)
    {
        return $this.GetSectionFromSettings($XmlSettings, 'Microsoft-Windows-TerminalServices-LocalSessionManager')
    }

    hidden [System.Xml.XmlElement] GetTerminalServicesRdpWinStationExtensions([System.Xml.XmlElement]$XmlSettings)
    {
        return $this.GetSectionFromSettings($XmlSettings, 'Microsoft-Windows-TerminalServices-RDP-WinStationExtensions')
    }

    hidden [System.Xml.XmlElement] GetWindowsTCPIPSection([System.Xml.XmlElement]$XmlSettings)
    {
        return $this.GetSectionFromSettings($XmlSettings, 'Microsoft-Windows-TCPIP')
    }

    hidden [System.Xml.XmlElement] GetWindowsDNSClientSection([System.Xml.XmlElement]$XmlSettings)
    {
        return $this.GetSectionFromSettings($XmlSettings, 'Microsoft-Windows-DNS-Client')
    }

    hidden [System.Xml.XmlElement] GetTCPIPInterfaces([System.Xml.XmlElement]$XmlSettings)
    {
        $XmlComponent = $this.GetWindowsTCPIPSection($XmlSettings)
        $result = $XmlComponent.ChildNodes | Where-Object { $_.Name -eq 'Interfaces' }
        if ($result -eq $null) {
            $result = $this.document.CreateElement('Interfaces', $this.document.DocumentElement.NamespaceURI)
            $XmlComponent.AppendChild($result) | Out-Null
        }
    
        return $result
    }

    hidden [System.Xml.XmlElement] GetTCPIPInterfaceFromInterfaces([System.Xml.XmlElement]$Interfaces, [string]$Identifier)
    {
        $interfaceNodes = $Interfaces.ChildNodes | Where-Object { $_.LocalName -eq 'Interface' }
        foreach($interfaceNode in $interfaceNodes) {
            $identifierNode = $interfaceNode.ChildNodes | Where-Object { $_.LocalName -eq $Identifier }
            if ($identifierNode.InnerText -eq $IdentifierNode) {
                return $interfaceNode
            }
        }   
        
        $interfaceNode = $this.document.CreateElement('Interface', $this.document.DocumentElement.NamespaceURI)
        $interfaceNode.SetAttribute('action', [UnattendXML]::WCM, 'add')
        $Interfaces.AppendChild($interfaceNode)

        $identifierNode = $this.document.CreateElement('Identifier', $this.document.DocumentElement.NamespaceURI)
        $identifierNodeText = $this.document.CreateTextNode($Identifier)
        $identifierNode.AppendChild($identifierNodeText)
        $interfaceNode.AppendChild($identifierNode)

        return $interfaceNode
    }

    hidden [System.Xml.XmlElement] GetTCPIPInterface([System.Xml.XmlElement]$XmlSettings, [string]$Identifier)
    {
        $interfaces =$this.GetTCPIPInterfaces($XmlSettings)
        return $this.GetTCPIPInterfaceFromInterfaces($interfaces, $Identifier)
    }

    hidden [System.Xml.XmlElement] GetOrCreateChildNode([System.Xml.XmlElement]$ParentNode, [string]$LocalName)
    {
        $result = $ParentNode.ChildNodes | Where-Object { $_.LocalName -eq $LocalName }
        if ($result -eq $null) {
            $result = $this.document.CreateElement($LocalName, $this.document.DocumentElement.NamespaceURI)
            $ParentNode.AppendChild($result)
        }

        return $result
    }

    hidden [System.Xml.XmlElement] GetTCPIPv4Settings([System.Xml.XmlElement]$Interface)
    {
        return $this.GetOrCreateChildNode($Interface, 'IPv4Settings')
    }

    hidden [System.Xml.XmlElement] GetTCPIPv4Setting([System.Xml.XmlElement]$Interface, [string]$SettingName)
    {
        $settings = $this.GetTCPIPv4Settings($Interface)
        return $this.GetOrCreateChildNode($settings, $SettingName)
    }

    hidden [System.Xml.XmlElement] GetTCPIPUnicastIPAddresses([System.Xml.XmlElement]$Interface)
    {
        return $this.GetOrCreateChildNode($Interface, 'UnicastIPAddresses')
    }

    hidden [System.Xml.XmlElement] GetTCPIPUnicastIPAddress([System.Xml.XmlElement]$Interface, [string]$KeyValue)
    {
        $unicastIPAddresses = $this.GetTCPIPUnicastIPAddresses($Interface)
        $result = $unicastIPAddresses.ChildNodes | Where-Object { $_.LocalName -eq 'IpAddress' -and $_.Attributes['keyValue'].'#text' -eq $KeyValue }
        if ($result -eq $null) {
            $result = $this.document.CreateElement('IpAddress', $this.document.DocumentElement.NamespaceURI)
            $result.SetAttribute('action', [UnattendXML]::WCM, 'add')
            $result.SetAttribute('keyValue',[UnattendXML]::WCM, $KeyValue)
            $unicastIPAddresses.AppendChild($result)
        }

        return $result
    }

    hidden [System.Xml.XmlElement] GetTCPIPRoutes([System.Xml.XmlElement]$Interface)
    {
        return $this.GetOrCreateChildNode($Interface, 'Routes')
    }

    hidden [System.Xml.XmlElement] GetTCPIPRoute([System.Xml.XmlElement]$Interface, [string]$Prefix)
    {
        $routes = $this.GetTCPIPRoutes($Interface)
        
        $routeNodes = ($routes.ChildNodes | Where-Object { $_.LocalName -eq 'Route' })
        $routeIdentifier = '0'

        # TODO : Better handling of when there's a missing identifier or prefix node
        foreach($routeNode in $routeNodes) {
            $prefixNode = ($routeNode.ChildNodes | Where-Object { $_.LocalName -eq 'Prefix' })
            if ($prefixNode.InnerText -eq $Prefix) {
                return $routeNode
            }

            $identifierNode = $routeNode.ChildNodes | Where-Object { $_.LocalName -eq 'Identifier' }
            
            if(([Convert]::ToInt32($identifierNode.InnerText)) -gt ([Convert]::ToInt32($routeIdentifier))) {
                $routeIdentifier = $identifierNode.InnerText
            }
        }        

        $routeIdentifier = ([Convert]::ToInt32($routeIdentifier)) + 1

        $routeNode = $this.document.CreateElement('Route', $this.document.DocumentElement.NamespaceURI)
        $routeNode.SetAttribute('action', [UnattendXML]::WCM, 'add')
        $routes.AppendChild($routeNode)

        $identifierNode = $this.document.CreateElement('Identifier', $this.document.DocumentElement.NamespaceURI)
        $identifierNodeText = $this.document.CreateTextNode($routeIdentifier.ToString())
        $identifierNode.AppendChild($identifierNodeText)
        $routeNode.AppendChild($identifierNode)

        $prefixNode = $this.document.CreateElement('Prefix', $this.document.DocumentElement.NamespaceURI)
        $prefixNodeText = $this.document.CreateTextNode($Prefix)
        $prefixNode.AppendChild($prefixNodeText)
        $routeNode.AppendChild($prefixNode)

        return $routeNode
    }

    hidden [System.Xml.XmlElement]GetFirstLogonCommandSection()
    {
        $xmlSettings = $this.GetOobeSystemSettings()
        $xmlComponent = $this.GetWindowsShellSetupSection($xmlSettings)
        $firstLogonCommands = $this.GetOrCreateChildNode($xmlComponent, 'FirstLogonCommands')
        return $firstLogonCommands
    }

    hidden [System.Xml.XmlElement]GetRunSynchronousSection()
    {
        $xmlSettings = $this.GetSpecializeSettings()
        $xmlComponent = $this.GetWindowsShellSetupSection($xmlSettings)
        return $this.GetOrCreateChildNode($xmlComponent, 'RunSynchronous')
    }

    hidden [string]ConvertToString([SecureString]$SecureString)
    {
        if (-not $SecureString)
        {
            return $null
        }

        $ManagedPasswordString = $null
        $PointerToPasswordString = $null
        try
        {
            $PointerToPasswordString = [System.Runtime.InteropServices.Marshal]::SecureStringToCoTaskMemUnicode($SecureString)
            $ManagedPasswordString = [System.Runtime.InteropServices.Marshal]::PtrToStringUni($PointerToPasswordString)
        }
        finally
        {
            [System.Runtime.InteropServices.Marshal]::ZeroFreeCoTaskMemUnicode($PointerToPasswordString)
        }
    
        return $ManagedPasswordString
    }

    hidden [void]SetAdministratorPassword([SecureString]$AdministratorPassword)
    {
        $xmlSettings = $this.GetOobeSystemSettings()
        $XmlComponent = $this.GetWindowsShellSetupSection($xmlSettings)

        $XmlUserAccounts = $this.document.CreateElement('UserAccounts', $this.document.DocumentElement.NamespaceURI)
        $XmlComponent.AppendChild($XmlUserAccounts)
        
        $XmlAdministratorPassword = $this.document.CreateElement('AdministratorPassword', $this.document.DocumentElement.NamespaceURI)
        $XmlUserAccounts.AppendChild($XmlAdministratorPassword) 

        $XmlValue = $this.document.CreateElement('Value', $this.document.DocumentElement.NamespaceURI)
        $XmlText = $this.document.CreateTextNode([Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes(($this.ConvertToString($AdministratorPassword)) + 'AdministratorPassword')))
        $XmlValue.AppendChild($XmlText)
        $XmlAdministratorPassword.AppendChild($XmlValue)

        $XmlPlainText = $this.document.CreateElement('PlainText', $this.document.DocumentElement.NamespaceURI)
        $XmlPassword = $this.document.CreateTextNode('false')
        $XmlPlainText.AppendChild($XmlPassword)
        $XmlAdministratorPassword.AppendChild($XmlPlainText) 
    }

    <#
        .SYNOPSIS
            Disables the EULA Page
        .LINK
            https://technet.microsoft.com/en-us/library/cc749231(v=ws.10).aspx
    #>
    [void] SetHideEula([bool]$hideEula) {
        $xmlSettings = $this.GetOobeSystemSettings()
        $XmlComponent = $this.GetWindowsShellSetupSection($xmlSettings)
        $oobeSettings = $this.GetOrCreateChildNode($XmlComponent, 'OOBE')

        $this.SetBoolNodeValue($oobeSettings, 'HideEULAPage', $hideEula)
    }

    <#
        .SYNOPSIS
            Skips the machine OOBE screens
        .LINK
            https://technet.microsoft.com/en-us/library/cc765947(v=ws.10).aspx
    #>
    [void] SetSkipMachineOOBE([bool]$skipMachineOOBE) {
        $xmlSettings = $this.GetOobeSystemSettings()
        $XmlComponent = $this.GetWindowsShellSetupSection($xmlSettings)
        $oobeSettings = $this.GetOrCreateChildNode($XmlComponent, 'OOBE')

        $this.SetBoolNodeValue($oobeSettings, 'SkipMachineOOBE', $skipMachineOOBE)
    }

    [void] SetAutoLogon([string]$Username, [string]$password, [int]$Count)
    {
        [SecureString]$securePassword = ConvertTo-SecureString -AsPlainText -Force -String $password
        $this.SetAutoLogon($username, $securePassword, $count)
    }

    [void] SetAutoLogon([string]$Username, [SecureString]$password, [int]$Count)
    {
        $xmlSettings = $this.GetOobeSystemSettings()
        $XmlComponent = $this.GetWindowsShellSetupSection($xmlSettings)
        $autoLogonNode = $this.GetOrCreateChildNode($XmlComponent, 'AutoLogon')
        
        $passwordNode = $this.GetOrCreateChildNode($autoLogonNode, 'Password')
        $this.SetTextNodeValue($passwordNode, 'Value', [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes(($this.ConvertToString($password)) + 'Password')))
        $this.SetBoolNodeValue($passwordNode, 'PlainText', $false)

        $this.SetBoolNodeValue($autoLogonNode, 'Enabled', $true)

        $this.SetInt32NodeValue($autoLogonNode, 'LogonCount', $Count)

        $this.SetTextNodeValue($autoLogonNode, 'Username', $Username)
    }

    hidden [void]SetTextNodeValue([System.Xml.XmlElement]$Parent, [string]$NodeName, [string]$Value)
    {
        $namedNode = $this.GetOrCreateChildNode($Parent, $NodeName)
        $textValueNode = $this.document.CreateTextNode($Value)
        $namedNode.AppendChild($textValueNode) 
    }

    hidden [void]SetBoolNodeValue([System.Xml.XmlElement]$Parent, [string]$NodeName, [bool]$Value)
    {
        $this.SetTextNodeValue($Parent, $NodeName, ($Value.ToString().ToLower()))
    }

    hidden [void]SetInt32NodeValue([System.Xml.XmlElement]$Parent, [string]$NodeName, [Int32]$Value)
    {
        $this.SetTextNodeValue($Parent, $NodeName, ($Value.ToString()))
    }

    UnattendXml() 
    {
        $XmlDecl = $this.document.CreateXmlDeclaration('1.0', 'utf-8', $Null)
        $XmlRoot = $this.document.DocumentElement
        $this.document.InsertBefore($XmlDecl, $XmlRoot)

        $this.XmlUnattended = $this.document.CreateElement('unattend', [UnattendXml]::XmlNs)
        $this.XmlUnattended.SetAttribute('xmlns:wcm', [UnattendXML]::WCM)
        $this.XmlUnattended.SetAttribute('xmlns:xsi', [UnattendXML]::XmlSchemaInstance)
        $this.document.AppendChild($this.XmlUnattended) 
    }

    <#
        .SYNOPSIS
            Configures the registered owner of the Windows installation
    #>
    [void]SetRegisteredOwner([string]$RegisteredOwner)
    {
        $offlineServiceSettings = $this.GetSpecializeSettings()
        $windowsShellSetupNode = $this.GetWindowsShellSetupSection($offlineServiceSettings)
        $this.SetTextNodeValue($windowsShellSetupNode, 'RegisteredOwner', $RegisteredOwner)
    }

    <#
        .SYNOPSIS
            Configures the registered organization of the Windows installation
    #>
    [void]SetRegisteredOrganization([string]$RegisteredOrganization)
    {
        $offlineServiceSettings = $this.GetSpecializeSettings()
        $windowsShellSetupNode = $this.GetWindowsShellSetupSection($offlineServiceSettings)
        $this.SetTextNodeValue($windowsShellSetupNode, 'RegisteredOrganization', $RegisteredOrganization)        
    }

    <#
        .SYNOPSIS
            Configures the name of the computer
    #>
    [void]SetComputerName([string]$ComputerName)
    {
        $offlineServiceSettings = $this.GetSpecializeSettings()
        $windowsShellSetupNode = $this.GetWindowsShellSetupSection($offlineServiceSettings)
        $this.SetTextNodeValue($windowsShellSetupNode, 'ComputerName', $ComputerName)        
    }

    <#
        .SYNOPSIS
            Configures the time zone for the computer
        .NOTES
            The configured time zone must be a valid value as defined by Microsoft
        .LINK
            https://technet.microsoft.com/en-us/library/cc749073(v=ws.10).aspx
    #>
    [void]SetTimeZone([string]$TimeZone)
    {
        $offlineServiceSettings = $this.GetSpecializeSettings()
        $windowsShellSetupNode = $this.GetWindowsShellSetupSection($offlineServiceSettings)
        $this.SetTextNodeValue($windowsShellSetupNode, 'TimeZone', $TimeZone)                
    }

    <#
        .SYNOPSIS
            Sets the state of whether DHCPv4 is enabled for a given interface
        .LINK
            https://technet.microsoft.com/en-us/library/cc748924(v=ws.10).aspx
    #>
    [void]SetDHCPEnabled([string]$InterfaceIdentifier, [bool]$Enabled)
    {
        $XmlSettings = $this.GetSpecializeSettings()
        $interfaceNode = $this.GetTCPIPInterface($XmlSettings, $InterfaceIdentifier)
        $interfaceTCPIPSettings = $this.GetTCPIPv4Settings($interfaceNode)
        $this.SetBoolNodeValue($interfaceTCPIPSettings, 'DhcpEnabled', $Enabled)
    }

    <#
        .SYNOPSIS
            Sets the state of whether IPv4 Router Discovery is enabled for a given interface
        .LINK
            https://technet.microsoft.com/en-us/library/cc749578(v=ws.10).aspx
            https://www.ietf.org/rfc/rfc1256.txt
            https://en.wikipedia.org/wiki/ICMP_Router_Discovery_Protocol
    #>
    [void]SetRouterDiscoveryEnabled([string]$InterfaceIdentifier, [bool]$Enabled)
    {
        $XmlSettings = $this.GetSpecializeSettings()
        $interfaceNode = $this.GetTCPIPInterface($XmlSettings, $InterfaceIdentifier)
        $interfaceTCPIPSettings = $this.GetTCPIPv4Settings($interfaceNode)
        $this.SetBoolNodeValue($interfaceTCPIPSettings, 'RouterDiscoveryEnabled', $Enabled)
    }

    <#
        .SYNOPSIS
            Sets the IPv4 routing metric value for the interface itself.
        .NOTES
            If you don't understand this value, set it to 10. 
        .LINK
            https://technet.microsoft.com/en-us/library/cc766415(v=ws.10).aspx
    #>
    [void]SetInterfaceIPv4Metric([string]$InterfaceIdentifier, [Int32]$Metric)
    {
        $XmlSettings = $this.GetSpecializeSettings()
        $interfaceNode = $this.GetTCPIPInterface($XmlSettings, $InterfaceIdentifier)
        $interfaceTCPIPSettings = $this.GetTCPIPv4Settings($interfaceNode)
        $this.SetInt32NodeValue($interfaceTCPIPSettings, 'Metric', $Metric)
    }

    <#
        .SYNOPSIS
            Sets the IPv4 address, subnet mask, ad default gateway for the given interface.
        .NOTES
            While multiple addresses are allowed on an interface, this function 
            assumes you'll have only one.

            It is recommended that when configuring a static IP address, you :
              * Disable DHCPv4 for the interface
              * Disable IPv4 ICMP Router Discovery for the interface
              * Configure a proper routing metric for the interface
        .LINK
            https://technet.microsoft.com/en-us/library/cc749412(v=ws.10).aspx
            https://technet.microsoft.com/en-us/library/cc749535(v=ws.10).aspx
    #>
    [void]SetInterfaceIPAddress([string]$InterfaceIdentifier, [string]$IPAddress, [Int32]$PrefixLength, [string]$DefaultGateway)
    {
        $XmlSettings = $this.GetSpecializeSettings()
        $interfaceNode = $this.GetTCPIPInterface($XmlSettings, $InterfaceIdentifier)
        $ipAddressNode = $this.GetTCPIPUnicastIPAddress($interfaceNode, '1')

        # TODO : Handle pre-existing inner text node.
        $ipAddressTextNode = $this.document.CreateTextNode(("{0}/{1}" -f $IPAddress,$PrefixLength))
        $ipAddressNode.AppendChild($ipAddressTextNode)

        # TODO : Create 'SetRoute' member function which modifies the value if it's already set
        $routeNode = $this.GetTCPIPRoute($interfaceNode, '0.0.0.0/0')
        
        $metricNode = $this.document.CreateElement('Metric', $this.document.DocumentElement.NamespaceURI)
        $metricNodeText = $this.document.CreateTextNode('10')
        $metricNode.AppendChild($metricNodeText)
        $routeNode.AppendChild($metricNode)

        $nextHopNode = $this.document.CreateElement('NextHopAddress', $this.document.DocumentElement.NamespaceURI)
        $nextHopNodeText = $this.document.CreateTextNode($DefaultGateway)
        $nextHopNode.AppendChild($nextHopNodeText)
        $routeNode.AppendChild($nextHopNode)
    }    

    <#
        .SYNOPSIS
            Sets DNS configuration for an interface 
        .NOTES
            This function is VERY "alpha version" and should not be used heavily until it's been completed
        .LINK
            https://technet.microsoft.com/en-us/library/ff716008(v=ws.10).aspx
    #>
    [void]SetDNSInterfaceSettings([string]$InterfaceIdentifier, [string[]]$DNSServerAddresses, [string]$DNSDomain)
    {
        $XmlSettings = $this.GetSpecializeSettings()
        $dnsSection = $this.GetWindowsDNSClientSection($XmlSettings)
        $interfacesSection = $this.GetOrCreateChildNode($dnsSection, 'Interfaces')
        
        # Verify we're not overwriting the interface settings
        $interfaceList = $interfacesSection.ChildNodes | Where-Object { $_.LocalName -eq 'Interface' }
        foreach($interface in $interfaceList) {
            $identifierNode = $interface.ChildNodes | Where-Object { $_.LocalName -eq 'Identifier' }
            if ($null -eq $identifierNode) {
                continue
            }

            if ($identifierNode.'#text' -eq $InterfaceIdentifier) {
                throw 'Editing DNS interface settings not implemented yet'
            }
        }

        $interface = $this.document.CreateElement('Interface', $this.document.DocumentElement.NamespaceURI)
        $interface.SetAttribute('action', [UnattendXML]::WCM, 'add')
        $interfacesSection.AppendChild($interface)

        $this.SetTextNodeValue($interface, 'Identifier', $InterfaceIdentifier)
        $this.SetBoolNodeValue($interface, 'EnableAdapterDomainNameRegistration', $false)
        $this.SetBoolNodeValue($interface, 'DisableDynamicUpdate', $false)
        $this.SetTextNodeValue($interface, 'DNSDomain', $DNSDomain)

        $dnsSearchOrder = $this.GetOrCreateChildNode($interface, 'DNSServerSearchOrder')
        for($i=0; $i -lt $DNSServerAddresses.Count; $i++) {
            $ipAddress = $this.document.CreateElement('IpAddress', $this.document.DocumentElement.NamespaceURI)
            $ipAddress.SetAttribute('action', [UnattendXML]::WCM, 'add')
            $ipAddress.SetAttribute('keyValue',[UnattendXML]::WCM, ($i + 1))
            $textValueNode = $this.document.CreateTextNode($DNSServerAddresses[$i])
            $ipAddress.AppendChild($textValueNode)

            $dnsSearchOrder.AppendChild($ipAddress)            
        }

        $this.SetBoolNodeValue($dnsSection, 'UseDomainNameDevolution', $true)
        $this.SetTextNodeValue($dnsSection, 'DNSDomain', $DNSDomain)
    }

    <#
        .SYNOPSIS
            Configures the administrator password for the new System
        .NOTES
            This command uses a plain text password.
        .LINK
            https://msdn.microsoft.com/en-us/library/windows/hardware/dn986490(v=vs.85).aspx
    #>
    [void] SetAdministratorPassword([string]$AdministratorPassword) {
        $this.SetAdministratorPassword((ConvertTo-SecureString $AdministratorPassword -AsPlainText -Force))
    }

    <#
        .SYNOPSIS
            Add's a command to the FirstLogonCommand list
        
        .PARAMETER Description
            A description of what the command is to do

        .PARAMETER command
            The command to run

        .LINK
            https://technet.microsoft.com/en-us/library/cc722150(v=ws.10).aspx
    #>
    [void] AddFirstLogonCommand([string]$Description, [string]$Command)
    {
        $firstLogonCommands = $this.GetFirstLogonCommandSection()
        $highestOrderNumber = 0
        $syncCommands = $firstLogonCommands.ChildNodes | Where-Object { $_.LocalName -eq 'SynchronousCommand' }
        foreach($syncCommand in $syncCommands) {
            $orderNumber = $syncCommand.ChildNodes | Where-Object { $_.LocalName -eq 'order' }
            $highestOrderNumber = [Math]::Max($highestOrderNumber, [Convert]::ToInt32($orderNumber.InnerText))
        }

        $orderValueNode = $this.document.CreateTextNode(($highestOrderNumber + 1).ToString())
        $orderNode = $this.document.CreateElement('Order', $this.document.DocumentElement.NamespaceURI)
        $orderNode.AppendChild($orderValueNode)

        $descriptionTextNode = $this.document.CreateTextNode($Description)
        $descriptionNode = $this.document.CreateElement('Description', $this.document.DocumentElement.NamespaceURI)
        $descriptionNode.AppendChild($descriptionTextNode)

        $commandTextNode = $this.document.CreateTextNode($Command)
        $commandNode = $this.document.CreateElement('CommandLine', $this.document.DocumentElement.NamespaceURI)
        $commandNode.AppendChild($commandTextNode)

        $syncCommandNode = $this.document.CreateElement('SynchronousCommand', $this.document.DocumentElement.NamespaceURI)
        $syncCommandNode.SetAttribute('action', [UnattendXML]::WCM, 'add')
        $syncCommandNode.AppendChild($orderNode)
        $syncCommandNode.AppendChild($descriptionNode)
        $syncCommandNode.AppendChild($commandNode)

        $firstLogonCommands.AppendChild($syncCommandNode)
    }

    <#
        .SYNOPSIS
            Adds a run synchronous command to the specialize section

        .DESCRIPTION
            Adds a command to the ordered list of synchronous commands to be executed as part of the startup process for post installation
            steps through sysprep.exe.

        .PARAMETER Description
            A description of the command to run on startup

        .PARAMETER Command
            The command to execute including Path and arguments

        .PARAMETER WillReboot
            Whether the command will reboot the system after running

        .LINK
            https://technet.microsoft.com/en-us/library/cc722359(v=ws.10).aspx
    #>
    [System.Xml.XmlElement] AddRunSynchronousCommand([string]$Description, [string]$Command, [EnumWillReboot]$WillReboot=[EnumWillReboot]::Never)
    {
        $runSynchronousSection = $this.GetRunSynchronousSection()
        $highestOrderNumber = 0
        $synchronousCommands = $runSynchronousSection.ChildNodes | Where-Object { $_.LocalName -eq 'RunSynchronousCommand' }
        foreach($synchronousCommand in $synchronousCommands) {
            $orderNumber = $synchronousCommand.ChildNodes | Where-Object { $_.LocalName -eq 'order' }
            $highestOrderNumber = [Math]::Max($highestOrderNumber, [Convert]::ToInt32($orderNumber.InnerText))
        }

        $orderValueNode = $this.document.CreateTextNode(($highestOrderNumber + 1).ToString())
        $orderNode = $this.document.CreateElement('Order', $this.document.DocumentElement.NamespaceURI)
        $orderNode.AppendChild($orderValueNode)

        $descriptionTextNode = $this.document.CreateTextNode($Description)
        $descriptionNode = $this.document.CreateElement('Description', $this.document.DocumentElement.NamespaceURI)
        $descriptionNode.AppendChild($descriptionTextNode)

        $pathTextNode = $this.document.CreateTextNode($Command)
        $pathNode = $this.document.CreateElement('Path', $this.document.DocumentElement.NamespaceURI)
        $pathNode.AppendChild($pathTextNode)

        $willRebootTextNode = $this.document.CreateTextNode([UnattendXml]::WillRebootToString($WillReboot))    
        $willRebootNode = $this.document.CreateElement('WillReboot', $this.document.DocumentElement.NamespaceURI)
        $willRebootNode.AppendChild($willRebootTextNode)

        $synchronousCommandNode = $this.document.CreateElement('RunSynchronousCommand', $this.document.DocumentElement.NamespaceURI)
        $synchronousCommandNode.SetAttribute('action', [UnattendXml]::WCM, 'add')
        $synchronousCommandNode.AppendChild($orderNode)
        $synchronousCommandNode.AppendChild($descriptionNode)
        $synchronousCommandNode.AppendChild($pathNode)
        $synchronousCommandNode.AppendChild($willRebootNode)
    
        $runSynchronousSection.AppendChild($synchronousCommandNode)
        return $synchronousCommandNode
    }

    <#
        .SYNOPSIS
            Adds a run synchronous command to the specialize section

        .DESCRIPTION
            Adds a command to the ordered list of synchronous commands to be executed as part of the startup process for post installation
            steps through sysprep.exe.

        .PARAMETER Description
            A description of the command to run on startup

        .PARAMETER Command
            The command to execute including Path and arguments

        .NOTES
            This function is an overload which defaults the 'WillReboot' value to never

        .LINK
            https://technet.microsoft.com/en-us/library/cc722359(v=ws.10).aspx
    #>
    [System.Xml.XmlElement] AddRunSynchronousCommand([string]$Description, [string]$Command)
    {
        return $this.AddRunSynchronousCommand($Description, $Command, [EnumWillReboot]::Never)
    }

    <#
        .SYNOPSIS
            Adds a run synchronous command to the specialize section

        .DESCRIPTION
            Adds a command to the ordered list of synchronous commands to be executed as part of the startup process for post installation
            steps through sysprep.exe.

        .PARAMETER Description
            A description of the command to run on startup

        .PARAMETER Domain
            The login domain to use for "Run As" for the command

        .PARAMETER Username
            The login username to use for "Run As" for the command

        .PARAMETER Password
            The login password to use for the "Run As" for the command

        .PARAMETER Command
            The command to execute including Path and arguments

        .PARAMETER WillReboot
            Whether the command will reboot the system after running

        .NOTES
            Warning, when providing login information in the unattend.xml, a copy of the unattend file may end up stored within
            the \Windows\Panther directory with the passwords in tact. The file should be explicitly removed upon completion

        .LINK
            https://technet.microsoft.com/en-us/library/cc722359(v=ws.10).aspx
    #>
    [System.Xml.XmlElement] AddRunSynchronousCommand([string]$Description, [string]$Domain, [string]$Username, [string]$Password, [string]$Command, [EnumWillReboot]$WillReboot=[EnumWillReboot]::Never)
    {
        $synchronousCommandNode = $this.AddRunSynchronousCommand($Description, $Command, $WillReboot)

        $domainTextNode = $this.document.CreateTextNode($domain)
        $domainNode = $this.document.CreateElement('Domain', $this.document.DocumentElement.NamespaceURI)
        $domainNode.AppendChild($domainTextNode)

        $usernameTextNode = $this.document.CreateTextNode($Username)
        $usernameNode = $this.document.CreateElement('Username', $this.document.DocumentElement.NamespaceURI)
        $usernameNode.AppendChild($usernameTextNode)

        $passwordTextNode = $this.document.CreateTextNode($Password)
        $passwordNode = $this.document.CreateElement('Password', $this.document.DocumentElement.NamespaceURI)
        $passwordNode.AppendChild($passwordTextNode)

        $credentialsNode = $this.document.CreateElement('Credentials', $this.document.DocumentElement.NamespaceURI)
        $credentialsNode.AppendChild($domainNode)
        $credentialsNode.AppendChild($usernameNode)
        $credentialsNode.AppendChild($passwordNode)
        $synchronousCommandNode.AppendChild($credentialsNode)

        return $synchronousCommandNode
    }

    <#
        .SYNOPSIS
            Adds a run synchronous command to the specialize section

        .DESCRIPTION
            Adds a command to the ordered list of synchronous commands to be executed as part of the startup process for post installation
            steps through sysprep.exe.

        .PARAMETER Description
            A description of the command to run on startup

        .PARAMETER Domain
            The login domain to use for "Run As" for the command

        .PARAMETER Username
            The login username to use for "Run As" for the command

        .PARAMETER Password
            The login password to use for the "Run As" for the command

        .PARAMETER Command
            The command to execute including Path and arguments

        .NOTES
            This is an overloaded function which sets the default value of WillReboot to never

            Warning, when providing login information in the unattend.xml, a copy of the unattend file may end up stored within
            the \Windows\Panther directory with the passwords in tact. The file should be explicitly removed upon completion

        .LINK
            https://technet.microsoft.com/en-us/library/cc722359(v=ws.10).aspx
    #>
    [System.Xml.XmlElement] AddRunSynchronousCommand([string]$Description, [string]$Domain, [string]$Username, [string]$Password, [string]$Command)
    {
        return $this.AddRunSynchronousCommand($Description, $Domain, $Username, $Password, $Command, [EnumWillReboot]::Never)
    }

    <#
        .SYNOPSIS
            Enables Windows Terminal Services to connect
        
        .LINK
            https://technet.microsoft.com/en-us/library/cc722017%28v=ws.10%29.aspx?f=255&MSPPError=-2147217396
    #>
    [void]SetRemoteDesktopEnabled()
    {
        $xmlSettings = $this.GetSpecializeSettings()
        $terminalServicesLocalSessionManager = $this.GetTerminalServicesLocalSessionManager($xmlSettings)
        $this.SetBoolNodeValue($terminalServicesLocalSessionManager, 'fDenyTSConnections', $false)
    }

    <#
        .SYNOPSIS
            Configures whether to support user or network level authentication for RDP sessions

        .LINK
            https://technet.microsoft.com/en-us/library/cc722192(v=ws.10).aspx
    #>
    [void]SetRemoteDesktopAuthenticationMode([EnumRdpAuthentication]$AuthenticationMode)
    {
        $xmlSettings = $this.GetSpecializeSettings()
        $terminalServicesRdpWinStationExtensions = $this.GetTerminalServicesRdpWinStationExtensions($xmlSettings)
        $this.SetTextNodeValue($terminalServicesRdpWinStationExtensions, 'UserAuthentication', [UnattendXml]::RdpAuthenticationModeToString($AuthenticationMode))
    }

    <#
        .SYNOPSIS
            Generates XML text that can be saved to a file 
    #>
    [string]ToXml()
    {
        $xmlWriterSettings = New-Object System.Xml.XmlWriterSettings
        $xmlWriterSettings.Indent = $true;
        $xmlWriterSettings.Encoding = [System.Text.Encoding]::Utf8

        $stringWriter = New-Object System.IO.StringWriter
        $xmlWriter = [System.Xml.XmlWriter]::Create($stringWriter, $xmlWriterSettings)

        $this.document.WriteContentTo($xmlWriter)

        $xmlWriter.Flush()
        $stringWriter.Flush()

        return $stringWriter.ToString() 
    }
}
<#
This code is written and maintained by Darren R. Starr from Conscia Norway AS.

License :

Copyright (c) 2017 Conscia Norway AS

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without limitation 
the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the Software 
is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#>

<# DependsOn './UnattendXml.ps1' #>

[DscResource()]
class cUnattendXml 
{
    [DscProperty(Key)]
    [string] $Path

    [DscProperty()]
    [string] $ComputerName

    [DscProperty()]
    [string] $RegisteredOwner

    [DscProperty()]
    [string] $RegisteredOrganization

    [DscProperty()]
    [string] $TimeZone

    [DscProperty()]
    [string] $LocalAdministratorPassword

    [DscProperty()]
	[string] $InterfaceName = 'Ethernet'

    [DscProperty()]
	[bool] $DisableDHCP = $false

    [DscProperty()]
	[bool] $DisableRouterDiscovery = $false

    [DscProperty()]
	[string] $IPAddress

    [DscProperty()]
	[int] $SubnetLength = 0

    [DscProperty()]
	[string] $DefaultGateway

    [DscProperty()]
	[string[]] $DNSServers

    [DscProperty()]
	[string] $DNSDomainName

    [DscProperty()]
	[int] $InterfaceMetric = 10

    [DscProperty()]
	[string] $ReadyRegistryKeyName = 'Status'

    [DscProperty()]
	[string] $ReadyRegistryKeyValue = 'Ready'

    [DSCProperty()]
    [bool] $ConfigurePushLCM = $false

    [DscProperty()]
    [bool] $EnableLocalWindowsRemoteManagement = $false

    [DscProperty()]
    [string] $MOFPath

    [cUnattendXml]Get() {
        return $this
    }

    [void]Set() {
        [string]$unattendText = $this.CreateUnattendXml()

        try {
            [IO.File]::WriteAllText($this.Path, $unattendText)
            #Set-Content -Path $unattendXmlFilePath -Value $text -Force
        } catch {
            Write-Error -Message ('Failed to set content of ' + $this.Path + ' - message - ' + $_.Exception.Message)
        }
    }

    [bool]Test() {
        if (-not (Test-Path -Path $this.Path)) {
            Write-Verbose -Message ('Unattend file "' + $this.Path + '" does not exist')
            return $false
        }

        [string]$unattendText = $this.CreateUnattendXml()

        $currentUnattendXml = Get-Content -Path $this.Path -Raw

        return $unattendText -eq $currentUnattendXml
    }

    hidden static [string]$PushLCMConfig = 
@'
[DSCLocalConfigurationManager()]
Configuration LCMConfig
{
    Node localhost { 
        Settings {
            RefreshMode='Push'
            RebootNodeIfNeeded=$true
            ActionAfterReboot='ContinueConfiguration'
        }
    }
}
LCMConfig -OutputPath 'c:\Windows\Panther\lcmmof'
Set-DscLocalConfigurationManager -Path 'c:\Windows\Panther\lcmmof' -ComputerName 'localhost'
'@ 

    hidden [string] CreateUnattendXml() {

        $unattend = [UnattendXml]::new()
        
        if(-not [String]::IsNullOrEmpty($this.ComputerName)) {
            $unattend.SetComputerName($this.ComputerName)
        }

        if(-not [String]::IsNullOrEmpty($this.RegisteredOwner)) {
            $unattend.SetRegisteredOwner($this.RegisteredOwner)
        }

        if(-not [String]::IsNullOrEmpty($this.RegisteredOrganization)) {
            $unattend.SetRegisteredOrganization($this.RegisteredOrganization)
        }

        if(-not [String]::IsNullOrEmpty($this.TimeZone)) {
            $unattend.SetTimeZone($this.TimeZone)
        }

        if(-not [String]::IsNullOrEmpty($this.LocalAdministratorPassword)) {
            $unattend.SetAdministratorPassword($this.LocalAdministratorPassword)
            $unattend.SetSkipMachineOOBE($true)
            $unattend.SetHideEULA($true)
        }

        if($this.DisableDHCP) {
            if([String]::IsNullOrEmpty($this.InterfaceName)) {
                throw [System.ArgumentException]::new(
                    'If configuring DHCP settings, the interface name must be provided',
                    'InterfaceName'
                )
            }

            if($this.DisableRouterDiscovery -eq $false) {
                throw [System.ArgumentException]::new(
                    'You should disable router discovery on interfaces where DHCP is disabled',
                    'IPAddress'
                )
            }

            $unattend.SetDHCPEnabled($this.InterfaceName, $false)
        }

        if($this.DisableRouterDiscovery) {
            if([String]::IsNullOrEmpty($this.InterfaceName)) {
                throw [System.ArgumentException]::new(
                    'If configuring DHCP settings, the interface name must be provided',
                    'InterfaceName'
                )
            }
            
            $unattend.SetRouterDiscoveryEnabled($this.InterfaceName, $false)
        }

        if(
            (-not [String]::IsNullOrEmpty($this.IPAddress)) -or
            ($this.SubnetLength -ne 0) -or
            (-not [String]::IsNullOrEmpty($this.DefaultGateway))
          ) {
            if(
                [String]::IsNullOrEmpty($this.IPAddress) -or
                ($this.SubnetLength -eq 0) -or
                [String]::IsNullOrEmpty($this.DefaultGateway)
            ) {
                #Write-Verbose -Message ('IPAddress null? = ' + [String]::IsNullOrEmpty($this.IPAddress).ToString())
                #Write-Verbose -Message ('IPAddress = ' + $this.IPAddress)
                #Write-Verbose -Message ('Default gateway null? = ' + [String]::IsNullOrEmpty($this.DefaultGateway).ToString())
                #Write-Verbose -Message ('Default gateway = ' + $this.DefaultGateway)
                #Write-Verbose -Message ('SubnetLength = ' + $this.SubnetLength)

                throw [System.ArgumentException]::new(
                    'If IP Address, Subnet length or Default Gateway are set, then all three must be set',
                    'IPAddress'
                )
            }

            if([String]::IsNullOrEmpty($this.InterfaceName)) {
                throw [System.ArgumentException]::new(
                    'If configuring IP settings, the interface name must be provided',
                    'InterfaceName'
                )
            }

            if($this.DisableDHCP -eq $false) {
                throw [System.ArgumentException]::new(
                    'You should disable DHCP on interfaces where static addresses are being set',
                    'IPAddress'
                )
            }

            $unattend.SetInterfaceIPAddress(
                    $this.InterfaceName, 
                    $this.IPAddress,
                    $this.SubnetLength, 
                    $this.DefaultGateway
                )
        }

        if((-not [String]::IsNullOrEmpty($this.DNSServers)) -or (-not [String]::IsNullOrEmpty($this.DNSDomainName))) {
            if([String]::IsNullOrEmpty($this.DNSServers) -or [String]::IsNullOrEmpty($this.DNSDomainName)) {
                # TODO : Consider allowing DNS servers to be set without a domain name
                throw [System.ArgumentException]::new(
                    'If configuring DNS settings, both the server and the domain name should be set',
                    'InterfaceName'
                )
            }
            if([String]::IsNullOrEmpty($this.InterfaceName)) {
                throw [System.ArgumentException]::new(
                    'If configuring DNS settings, the interface name must be provided',
                    'InterfaceName'
                )
            }

            $unattend.SetDNSInterfaceSettings($this.InterfaceName, $this.DNSServers, $this.DNSDomainName)
        }

        if($this.InterfaceMetric -ne -1) {
            if([String]::IsNullOrEmpty($this.InterfaceName)) {
                throw [System.ArgumentException]::new(
                    'If configuring interface metric settings, the interface name must be provided',
                    'InterfaceName'
                )
            }
            $unattend.SetInterfaceIPv4Metric($this.InterfaceName, 10)
        }

        [bool]$SetAutoLogon = $false

        if($this.EnableLocalWindowsRemoteManagement) {
            $unattend.AddFirstLogonCommand(
                'Enable local Windows Remote Management',
                '%windir%\system32\winrm.cmd quickconfig /quiet'
            )
            $SetAutoLogon = $true
        }

        if($this.ConfigurePushLCM) {
            if(-not $this.EnableLocalWindowsRemoteManagement) {
                throw [System.ArgumentException]::new(
                    'EnableLocalWindowsRemoteManagement is required to use ConfigurePushLCM',
                    'ConfigurePushLCM'
                )
            }            
            $unattend.AddFirstLogonCommand(
                'Configure DSC Push Mode',
                ("%windir%\System32\WindowsPowerShell\v1.0\powershell.exe " +
                    'C:\Windows\Panther\Scripts\LCMSetPushLocal.ps1')
                    # "-nologo -encodedCommand "+ 
                    # [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes([cUnattendXml]::PushLCMConfig)))
            )

            $SetAutoLogon = $true
        }

        if(-not [string]::IsNullOrEmpty($this.MOFPath)) {
            if(-not $this.EnableLocalWindowsRemoteManagement) {
                throw [System.ArgumentException]::new(
                    'EnableLocalWindowsRemoteManagement is required to use MOFPath',
                    'MOFPath'
                )
            }

            $unattend.AddFirstLogonCommand(
                'Start DSC Configuration',
                ("%windir%\System32\WindowsPowerShell\v1.0\powershell.exe -nologo -command `"Start-DSCConfiguration -Path 'C:" + $this.MOFPath + "' -verbose -wait -force `"")
            )

            $SetAutoLogon = $true
        }

        if((-not [String]::IsNullOrEmpty($this.ReadyRegistryKeyName)) -or (-not [String]::IsNullOrEmpty($this.ReadyRegistryKeyValue))) {
            if([String]::IsNullOrEmpty($this.ReadyRegistryKeyName) -or [String]::IsNullOrEmpty($this.ReadyRegistryKeyValue)) {
                throw [System.ArgumentException]::new(
                    'If configuring a registry key name and value to be set once unattend.xml is mostly done, then both must be defined',
                    'ReadyRegistryKeyName'
                )
            }

            $unattend.AddFirstLogonCommand(
                'Inform Host Of Ready State', 
                '%windir%\system32\reg.exe add "HKLM\Software\Microsoft\Virtual Machine\Guest" /V ' + 
                $this.ReadyRegistryKeyName + 
                ' /T REG_SZ /D ' +
                $this.ReadyRegistryKeyValue
            )
        }

        if($SetAutoLogon) {
            if ([String]::IsNullOrEmpty($this.LocalAdministratorPassword)) {
                throw [System.ArgumentException]::new(
                    'When configuring features (MOFPath, EnableLocalWindowsRemoteManagement, RegistryKeys), it is necessary to supply a local administrator password',
                    'LocalAdministratorPassword'
                )
            }

            $unattend.SetAutoLogon('Administrator', $this.LocalAdministratorPassword, 1)
        }

        return $unattend.ToXml().Trim()
    }
}
<#
This code is written and maintained by Darren R. Starr from Conscia Norway AS.

License :

Copyright (c) 2017 Conscia Norway AS

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without limitation 
the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the Software 
is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#>

<# 
    .SYNOPSIS
        A resource for creating a differencing VHD disk image relative to a parent image
#>
[DscResource()]
class cDifferencingVHD 
{
    [DscProperty(Key)]
    [string] $VHDPath

    [DSCProperty(Mandatory)]
    [string] $ParentVHDPath

    <#
        .SYNOPSIS
            Resource Get
    #>
    [cDifferencingVHD] Get()
    {
        $result = [cDifferencingVHD]::new()
        $result.ParentVHDPath = $this.ParentVHDPath
        $result.VHDPath = $this.VHDPath
        return $result
    }

    <#
        .SYNOPSIS
            Resource Test
    #>
    [bool] Test()
    {
        Write-Verbose -Message ('Testing for presence of [' + $this.ParentVHDPath +'])')
        if (-not (Test-Path -Path $this.PArentVHDPath)) {
            Write-Verbose -Message('VHD File [' + $this.ParentVHDPath + '] not present')
            return $false
        }

        Write-Verbose -Message ('Testing for presence of [' + $this.VHDPath +'])')
        if (-not (Test-Path -Path $this.VHDPath)) {
            Write-Verbose -Message('VHD File [' + $this.VHDPath + '] not present')
            return $false
        }

        Write-Verbose -Message ('Attempt to get handle to the VHD file')
        $vhd = $null
        try {
            $vhd = Get-VHD -Path $this.VHDPath
            
            if($null -eq $vhd) {
                # TODO: throw here?
                Write-Error -Message ('Unknown error getting handle to [' + $this.VHDPath + ']')
                return $false
            }
        } catch {
            # TDOD : throw here?
            Write-Error -Message ('Failed to get handle to VHD file [' + $this.VHDPath + ']')
            return $false
        }

        Write-Verbose -Message ('Handle obtained')

        if($null -eq $vhd.ParentPath) {
            throw [Exception]::new(
                'Existing VHD [' + $this.VHDPath + '] is not a differencing image'
            )
        }

        Write-Verbose -Message ('Parent path of VHD (as seen within the VHD) is [' + $vhd.ParentPath + ']')

        $resolvedParentVhdPath = Resolve-Path -Path $this.ParentVHDPath -Relative:$false
        if(-not ($resolvedParentVhdPath -like $vhd.ParentPath)) {
            throw [Exception]::new(
                'Path specified as option [' + $this.ParentVHDPath + '] is not equal to the path within the VHD [' + $resolvedParentVhdPath + ']'
            )
        }

        return $true
    }

    <#
        .SYNOPSIS
            Resource Set
    #>
    [void] Set()
    {
        Write-Verbose -Message ('Testing for presence of [' + $this.ParentVHDPath +'])')
        if (-not (Test-Path -Path $this.PArentVHDPath)) {
            throw [System.IO.FileNotFoundException]::new(
                'Parent VHD file not found',
                $this.ParentVHDPath ,
                [System.ArgumentException]::new(
                    'VHD file specified not present',
                    'ParentVHDPath'
                )
            )
        }

        Write-Verbose -Message ('Testing for presence of [' + $this.VHDPath +'])')
        if (Test-Path -Path $this.VHDPath) {
            throw [System.ArgumentException]::new(
                'VHD File [' + $this.VHDPath + '] already exists and should not be overwritten',
                'VHDPath'
            )
        }

        $parentVHD = $null
        Write-Verbose -Message ('Getting handle to parent VHD')
        try {
            $parentVHD = Get-VHD -Path $this.ParentVHDPath
        } catch {
            throw [Exception]::new(
                'Failed to get handle to parent VHD [' + $this.ParentVHDPath + ']',
                $_.Exception
            )
        }

        Write-Verbose -Message ('Getting mounted position of parent VHD')
        try {
            $MountedDiskImage = Get-WmiObject -Namespace 'root\virtualization\v2' -query "SELECT * FROM MSVM_MountedStorageImage WHERE Name ='$($this.ParentVHDPath.Replace("\", "\\"))'"

            if($null -ne $MountedDiskImage) {
                throw [System.ArgumentException]::new(
                    '[' + $this.ParentVHDPath + '], ParentVHD is already mounted and can''t be used as a differencing disk',
                    'ParentVHDPath'
                )
            }
        } catch {
            if($_.Exception.Message.StartsWith('[')) {
                throw $_.Exception
            }

            throw [System.Exception]::new(
                'Failed to get information from virtualization root regarding mounted images',
                $_.Exception
            )
        }

        $vhdFolderInfo = [System.IO.FileInfo]::new($this.VHDPath)
        if(($null -eq $vhdFolderInfo) -or ($null -eq $vhdFolderInfo.Directory)) {
            throw [System.ArgumentException]::new(
                '[' + $this.VHDPath + '] does not appear to contain a valid parent directory within its path'
            )
        }
        
        Write-Verbose -Message ('Testing for presence of folder of new VHD file [' + $vhdFolderInfo.Directory.FullName + ']')
        if(-not (Test-Path -Path $vhdFolderInfo.Directory.FullName)) {
            throw [System.IO.DirectoryNotFoundException]::new(
                'Containing directory for new VHD file does not exist',
                $vhdFolderInfo.Directory.FullName
            )
        }

        Write-Verbose -Message ('Attempting to create new differencing VHD file [' + $this.VHDPath + '] using [' + $this.ParentVHDPath + '] as its parent')
        $vhd = $null
        try {
            $vhd = New-VHD -Path $this.VHDPath -ParentPath $this.ParentVHDPath -Differencing 

            if ($null -eq $vhd) {
                throw [Exception]::new(
                    'Unknown error calling New-VHD, aborting'
                )
            }
        } catch {
            throw [Exception]::new(
                'Failed to create differencing VHD file with source  VHD file [' + $this.VHDPath + '] using [' + $this.ParentVHDPath + '] as its parent',
                $_.Exception
            )
        }

        Write-Verbose -Message ('New VHD file [' + $this.VHDPath + '] created')
    }
}
<#
This code is written and maintained by Darren R. Starr from Conscia Norway AS.

License :

Copyright (c) 2017 Conscia Norway AS

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without limitation 
the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the Software 
is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#>

<# 
    .SYNOPSIS
        A resource for monitoring guest virtual machines in Hyper-V to wait for registry values to change
#>
[DscResource()]
class cGuestRegistryKey 
{
    [DscProperty(Key)]
    [string] $VMName

    [DSCProperty(Mandatory)]
    [string] $KeyName

    [DSCProperty(Mandatory)]
    [string] $KeyValue

    [DSCProperty()]
    [int] $TimeOutSeconds = 180

    [DSCProperty()]
    [int] $PollIntervalSeconds = 1
    
    <#
        .SYNOPSIS
            Resource Get
    #>
    [cGuestRegistryKey] Get()
    {
        $result = [cGuestRegistryKey]::new()
        $result.VMName = $this.VMName
        $result.KeyName = $this.KeyName
        $result.KeyValue = $this.KeyValue
        $result.TimeOutSeconds = $this.TimeOutSeconds
        $result.PollIntervalSeconds = $this.PollIntervalSeconds

        return $result
    }

    <#
        .SYNOPSIS
            Resource Test
    #>
    [bool] Test()
    {
        Write-Verbose -Message ('VMName = ' + $this.VMName)
        Write-Verbose -Message ('KeyName = ' + $this.KeyName)
        Write-Verbose -Message ('KeyValue = ' + $this.KeyValue)
        Write-Verbose -Message ('TimeOutSeconds = ' + $this.TimeOutSeconds.ToString())
        Write-Verbose -Message ('PollIntervalSeconds = ' + $this.PollIntervalSeconds.ToString())

        $startTime = [DateTime]::Now
        $timeDifference = (([DateTime]::Now).Subtract($startTime)).TotalSeconds
        $vm = $null

        # TODO: Hackish workaround because I can't seem to pass $this to Get-WMIObject -Filter
        $virtualMachineName = $this.VMName

        Write-Verbose -Message ('Getting handle to virtual machine [' + $this.VMName + ']')
        while(($null -eq $vm) -and ($timeDifference -lt $this.TimeOutSeconds))
        {
            try {
                Write-Debug -Message ('Poll')
                $vm = Get-WmiObject -Namespace root\virtualization\v2 -Class Msvm_ComputerSystem -Filter "ElementName = '$virtualMachineName'"
            } catch {
                Start-Sleep -Seconds $this.PollIntervalSeconds
                $timeDifference = (([DateTime]::Now).Subtract($startTime)).TotalSeconds
            }

            if ($null -ne $vm) {
                break
            }
        }

        if ($null -eq $vm) {
            return $false
        }
 
        # TODO: Hackish workaround because I can't seem to pass $this to Get-WMIObject -Filter
        $registryKeyName = $this.KeyName

        $timeDifference = (([DateTime]::Now).Subtract($startTime)).TotalSeconds
        Write-Verbose -Message ('Obtained handle to virtual machine, waiting for value (timeout in ' + ($this.TimeOutSeconds - $timeDifference) + ' seconds)')
        $guestKeyValue = $null   
        while(($guestKeyValue -ne $this.KeyValue) -and ($timeDifference -lt $this.TimeOutSeconds)) {
            $exchangeItems = $vm.GetRelated("Msvm_KvpExchangeComponent").GuestExchangeItems 
            if ($null -ne $exchangeItems) {
                Write-Debug -Message ('Found ' + $exchangeItems.Count + ' items')
                foreach($exchangeItem in $exchangeItems) {
                    $GuestExchangeItemXml = ([XML]$exchangeItem).SelectSingleNode("/INSTANCE/PROPERTY[@NAME='Name']/VALUE[child::text() = '$registryKeyName']")
            
                    if ($GuestExchangeItemXml -ne $null) { 
                        $guestKeyValue = ($GuestExchangeItemXml.SelectSingleNode("/INSTANCE/PROPERTY[@NAME='Data']/VALUE/child::text()").Value)
                        if ($guestKeyValue -eq $this.KeyValue) {
                            break
                        }
                    } 
                }
            } 

            if ($guestKeyValue -ne $this.KeyValue) {
                Write-Debug -Message ('Sleep')
                Start-Sleep -Seconds $this.PollIntervalSeconds
                $timeDifference = (([DateTime]::Now).Subtract($startTime)).TotalSeconds
            }
        }

        if ($guestKeyValue -ne $this.KeyValue) {
            return $false
        }

        Write-Verbose -Message ('Registry key ' + $this.KeyName + ' = ' + $guestKeyValue)

        return $true
    }

    <#
        .SYNOPSIS
            Resource Set
    #>
    [void] Set()
    {
        throw [System.Exception]::new(
            'cGuestRegistryKey is a monitoring (test only) resource and should not be used for setting state'
        )
    }
}
<#
  .SYNOPSIS
      Basic MOF file parser
  
  .DESCRIPTION
      A basic MOF file parser. This parser is a recursive descent parser written without
      any tools such as a PEG generator. In addition, it was written from evaluating the
      format of the .MOF files generated by DSC from my other modules. It is not feature
      complete or name accurate as I didn't make use of the standards document which was
      over 50 pages of extreme details.
 
  .AUTHOR
      Darren R. Starr
 
  .COPYRIGHT
      2017 Conscia Norway AS
 
  .NOTES
      This code serves as a proof of concept that :
        a) Recursive descent parsers are practical to author in PowerShell
        b) A PEG generator would be meaningful for PowerShell and could be self-hosting as well
        c) I can still program :)

      The parser is layed out in three sections :
        - Generic parser support classes
        - Abstract Syntax Tree classes
        - The parser
#> 

<#=======================================================================
 #                 Generic parser support classes 
 #======================================================================#>

<#
    .SYNOPSIS
        A class to maintain the state of the parser, it is a basic stream management class at this point

    .DESCRIPTION
        This class is a combination of a stream and a state manager. ParserState stores the full text
        of the file to parse and also the current index within the text. As part of the class, there
        are functions used for pushing and popping the state (currently by managing a stack of indexes)
        and also functions for matching literals and regular expressions.

    .NOTES
        A later version should include
            <li>Translation of index to line and column number</li>
            <li>Injecting 'includes' within the text at the current state. On Pop(), the include should be undone</li>
#>
class ParserState {
    <#
        .SYNOPSIS
            The text to parse
    #>
    hidden [string]$SourceText

    <#
        .SYNOPSIS
            The current index within the text
    #>
    hidden [int]$Index = 0

    <#
        .SYNOPSIS
            The state stack. Allowing pushes and pops of the current parser state
    #>
    hidden [System.Collections.Stack] $Stack = @()

    <#
        .SYNOPSIS
            Constructor
    #>    
    ParserState([string]$sourceText)
    {
        $this.SourceText = $sourceText
    }

    <#
        .SYNOPSIS
            Advances the read index by the given number of characters
    #>
    [void]Skip([int]$by)
    {
        $this.Index += $by
    }


    <#
        .SYNOPSIS
            Pushes the current state of this object
    #>
    [void]Push() {
        $this.Stack.Push($this.Index)
    }

    <#
        .SYNOPSIS
            Pops the previous state of this object

        .NOTES
            Before popping the stack is checked for pushed states. If there are no
            previous states on the stack, the function throws System.IndexOutOfRangeException
    #>
    [void]Pop() {
        if($this.Stack.Length -le 0) {
            throw [System.IndexOutOfRangeException]::new(
                'Parser state: No values left to pop'
            )
        }
        $this.Index = $this.Stack.Pop()    
    }

    <#
        .SYNOPSIS
            Commits the current state of the stack

        .NOTES
            Commits means that it simply pops the previous state of the stack
            without actually using it.
    #>
    [void]Commit() {
        if($this.Stack.Length -le 0) {
            throw [System.IndexOutOfRangeException]::new(
                'Parser state: No values left to pop'
            )
        }
        $this.Stack.Pop()
    }

    <#
        .SYNOPSIS
            Returns true when input is at or past end
    #>
    [bool]AtEnd()
    {
        return ($this.Index -ge $this.SourceText.Length)
    }

    <#
        .SYNOPSIS
            Returns the text at the given stream position with the given length

        .NOTES
            When an invalid start position or length is provided, then this function
            throws System.IndexOutOfRangeException
    #>
    [string]GetText([int]$startPosition, [int]$length)
    {
        if(
            ($startPosition -lt 0) -or
            ($length -lt 0) -or
            ($startPosition -ge $this.SourceText.Length) -or
            (($startPosition + $length - 1) -ge $this.SourceText.Length)
        ) {
            throw [System.IndexOutOfRangeException]::new(
                'An attempt has been made to retrieve data the is positioned outside of this text buffer'
            )
        }

        return $this.SourceText.Substring($startPosition, $length)
    }

    <#
        .SYNOPSIS
            Returns the next character in the stream and advances in the input pointer
        
        .NOTES
            If the stream position is at or past the end of the stream, this function
            throws System.IndexOutOfRangeException
    #>
    [string]GetNextChar()
    {
        if($this.AtEnd()) {
            throw [System.IndexOutOfRangeException]::new(
                'Input past end'
            )
        }

        [string]$result = $this.SourceText[$this.Index]

        $this.Index++

        return $result
    }


    <#
        .SYNOPSIS
            Matches the current position of the stream to the literal text provided.

        .DESCRIPTION
            The result of this function is position information regarding the position of the
            match and the length of the match.
    #>
    [ParserStateMatch]MatchLiteralText([string]$pattern)
    {
        $textIndex = $this.Index
        $patternIndex = 0

        while(
            ($textIndex -lt $this.SourceText.Length) -and 
            ($patternIndex -lt $pattern.Length) -and
            ($this.SourceText[$textIndex] -eq $pattern[$patternIndex])
        ) {
            $textIndex++
            $patternIndex++
        }

        $result = $null
        if ($patternIndex -eq $pattern.Length) {
            $result = [ParserStateMatch] @{
                State = $this
                StartIndex = $this.Index
                Length = $textIndex - $this.Index
            }
            $this.Skip($result.Length)
        }

        return $result
    }

    <#
        .SYNOPSIS
            Matches the text at the current position against the given regular expression

        .DESCRIPTION
            The result of this function is match criteria of what has been found, where and how long.
    #>
    [ParserStateMatch]MatchExpression([string]$pattern)
    {
        $match = [RegEx]::new('\G' + $pattern).Match($this.SourceText, $this.Index)
        if ($null -eq $match) {
            return $null
        }
        
        if (-not $match.Success) {
            return $null
        }
        
        $result = [ParserStateMatch] @{
            State = $this
            StartIndex = $this.Index
            Length = $match.Length
        } 

        $this.Skip($result.Length)
        return $result
    }
}

<#
    .SYNOPSIS
        A structure for returning information regarding matched text within a parser stream.
#>
class ParserStateMatch {

    <#
        .SYNOPSIS
            The text stream in which the match occurs
    #>
    [ParserState]$State

    <#
        .SYNOPSIS
            The starting position of the text within the stream
    #>
    [int]$StartIndex

    <#
        .SYNOPSIS
            The length of the match
    #>
    [int]$Length

    <#
        .SYNOPSIS
            Returns the text represented by this match
    #>
    [string] GetText() {
        return $this.State.GetText($this.StartIndex, $this.Length)
    }
}

<#=======================================================================
 #                 Abstract Syntax Tree (AST) elements
 #=======================================================================#>

class MOFElement {
}

class MOFDocumentElement : MOFElement
{
}

class MOFDocument : MOFElement
{
    [MOFDocumentElement[]] $Elements = @()   
}

class MOFComment : MOFDocumentElement
{
    [string]$Comment

    MOFComment([ParserStateMatch]$match) 
    {
        $this.Comment = $match.GetText()
    }

    [string]ToString() {
        return $this.Comment
    }
}

class MOFInstanceOf : MOFDocumentElement
{
    [MOFLiteralName]$Name
    [MOFVariable]$As
    [MOFStructureValue]$Value

    MOFInstanceOf([MOFLiteralName]$name, [MOFInstanceOfAs]$as, [MOFStructureValue]$value)
    {
        $this.Name = $name
        if($null -ne $as) {
            $this.As = $as.Variable
        }

        $this.Value = $value
    }

    [string]ToString() {
        if($null -eq $this.As) {
            return $this.Name.ToString()
        } else {
            return ($this.Name.ToString() + ' as ' + $this.As.ToString())
        }
    }
}

class MOFValue : MOFElement
{
}

class MOFStringValue : MOFValue
{
    [string]$Value
    
    MOFStringValue([string]$value) {
        $this.Value = $value
    }

    [string]ToString() {
        return $this.Value
    }
}

class MOFIntegerValue : MOFValue
{
    [Int64]$Value

    MOFIntegerValue([Int64]$value) {
        $this.Value = $value
    }

    [string]ToString() {
        return $this.Value
    }    
}

class MOFBooleanValue : MOFValue
{
    [bool]$Value

    MOFBooleanValue([bool]$value) {
        $this.Value = $value
    }

    [string]ToString() {
        return $this.Value.ToString()
    }
}

class MOFVariable : MOFValue
{
    [string] $Name

    MOFVariable([string]$name)
    {
        $this.Name = $name
    }

    [string]ToString() {
        return $this.Name
    }
}

class MOFLiteralName : MOFElement
{
    [string] $Name

    MOFLiteralName([string]$name)
    {
        $this.Name = $name
    }

    [string]ToString() {
        return $this.Name
    }
}

class MOFInstanceOfAs : MOFElement
{
    [MOFVariable]$Variable

    MOFInstanceOfAs([MOFVariable]$variable)
    {
        $this.Variable = $variable
    }

    [string]ToString() {
        return $this.Variable.ToString()
    }
}

class MOFWhiteSpace : MOFDocumentElement
{
    [string] $Content

    MOFWhiteSpace([string]$content) 
    {
        $this.Content = $content
    }
}

class MOFAssignment : MOFElement
{
    [MOFLiteralName]$Name
    [MOFValue]$Value

    MOFAssignment([MOFLiteralName]$name, [MOFValue]$value) {
        $this.Name = $name
        $this.Value = $value
    }

    [string]ToString() {
        return ($this.Name.ToString() + ' = ' + $this.Value.ToString())
    }
}

class MOFStructureValue : MOFValue
{
    [MOFAssignment[]]$Values

    MOFStructureValue([MOFAssignment[]]$values) 
    {
        $this.Values = $values
    }

    [string]ToString() {
        return ('Structure, ' + $this.Values.Count + ' items')
    }
}

class MOFArrayValue : MOFValue
{
    [MOFValue[]]$Values

    MOFArrayValue([MOFValue[]]$values) 
    {
        $this.Values = $values
    }

    [string]ToString() {
        return $this.Values.ToString()
    }
}

<#=======================================================================
 #                 Generic parser support classes 
 #======================================================================#>

<#
    .SYNOPSIS
        A primitive MOF file parser

    .DESCRIPTION
        The purpose of this parse is to hopefully make it possible to find the DSC resource dependencies
        of a MOF file generated by a Powershell DSC configuration.

        This parser was hand-coded as there are no PEG tools available for generating Powershell classes.
        Although it is possible to use C# from Powershell, the overall goal of this project is to eliminate
        data center automation requirements needing other programming languages. And frankly, it's not 
        difficult to read or maintain a simple parse like this in Powershell.

    .ISSUES
        There is one major known issue with the parser which is that the regular MatchExpression code 
        which matches a regular expression seems impossible to implement using [RegEx]::match cleanly
        because it appears to be impossible to search from start of string (regex '^') from an initial
        index. So this code instead performs the search without the '^' and then compares the position of
        the match. This is ridiculously wrong to do. The better solution is likely to be to use Substring()
        however this could be an issue of mutability and have a very high cost of copying.

    .AUTHOR
        Darren R. Starr <darren dot starr _at= conscia d0t no>

    .NOTES
        The grammar of the parser as it currently stands is as follows :
            
            DocumentElements<MOFDocumentElement[]>
                = WS* element:DocumentElement elements:DocumentElements? WS* { 
                    return [MOFDocumentElement[]] @(element, elements) 
                }

            DocumentElement<MOFDocumentElement>
                = c:Comment { return c }
                | i:InstanceOf { return i }

            InstanceOf<MOFInstanceOf> 
                = WS* 'instance' WS+ 'of' WS+ name:LiteralName as:InstanceOfAs? value:StructureValue WS* ';' {
                    return MOFInstanceOf::new(name, as, value)
                }
            
            StructureValue<MOFAssignment[]>
                = WS* '{' assignments:Assignments WS* '}' { return assignments }
            
            Assignments => 
                = assignment:Assignment assignments:Assignments? {
                    return [MOFAssignment[]] @( assignment, assignments )
                }
            
            Assignment<MOFAssignment>
                = WS* name:LiteralName WS* '=' value:Value WS* ';' {
                    return [MOFAssignment]::new(name, value)
                }
            
            Value<MOFValue>
                = variable:Variable { return variable }
                | stringValue:StringValue { return stringValue }
                | booleanValue:BooleanValue { return booleanValue }
                | arrayValue:ArrayValue { return arrayValue }
            
            ArrayValue<MOFValue[]>
                = WS* '{' values:ArrayValueItems WS* '}' { return values }
            
            ArrayValueItems<MOFValue[]>
                = value:Value WS* (',' values:Values)? { return [MOFValue[]] @(value, values) }
            
            BooleanValue<MOFBooleanValue>
                = WS* 'True' { return [MOFBooleanValue]::new($true) }
                | WS* 'False' { return [MOFBooleanValue]::new($false) }

            IntegerValue<MOFIntegerValue>
                = hexValue:HexIntegerValue { return hexValue }
                | decimalValue:DecimalIntegerValue { return decimalValue }

            HexIntegerValue<MOFIntegerValue>
                = WS* '0x' hexValue:[0-9a-fA-F]+ { return [MOFIntegerValue]::new([Convert]::ToInt64($hexValue, 16)) }

            DecimalIntegerValue<MOFIntegerValue>
                = WS* decimalValue:(-?[0-9]+) { return [MOFIntegerValue]::new([Convert]::ToInt64($decimalValue, 10)) }

            StringValue<MOFStringValue>
                = WS* '"' stringPart:StringPart? '"' { return [MOFStringValue]::new('' + stringPart.Value) }
            
            StringPart<MOFStringValue>
                = segment:StringPartSegment stringPart:StringPart? { return [MOFStringValue]new(segment.Value + stringPart.Value) }
            
            StringPartSegment<MOFStringValue>
                = escapedPart:EscapedStringPart { return escapedPart } 
                | stringPart:[^\\"]+ { return [MOFStringValue]::new(stringPart) }
            
            EscapedStringPart<MOFStringValue>
                = '\' escapedChar:. { return [MOFStringValue]::new(escapedChar) }
            
            InstanceOfAs<MOFInstanceOfAs>
                = WS* 'as' WS+ variable:Variable { return [MOFInstanceOfAs(variable) }
            
            Variable<MOFVariable>
                = WS* variable:'\$_?([A-Za-z][A-Za-z0-9_]*)' { return [MOFVariable]::new(variable) }
            
            LiteralName<MOFLiteralName>
                = name:'_?[A-Za-z][A-Za-z_]*' { return [MOFLiteralName]::new(name) }
            
            WS<MOFWhiteSpace>
                = ws:'\s+' { return [MOFWhiteSpace]::new(ws) }
            
            Comment<MOFComment>
                = blockComment:BlockComment { return blockComment }
            
            BlockComment<MOFComment>
                = blockComment:'\/\*(\*(?!\/)|[^*])*\*\/' { return [MOFComment]::new(blockComment) }
#>
class MOFParser {

    [MOFDocumentElement[]] Parse([string]$sourceText) 
    {
        [ParserState]$state = [ParserState]::new($sourceText)

        $result = $this.ParseDocumentElements($state) 

        if (-not $state.AtEnd()) {
            throw 'Did not make it to the end'
        }

        return $result
    }

    # DocumentElements => WS* DocumentElement DocumentElements? WS*
    hidden [MOFDocumentElement[]] ParseDocumentElements([ParserState]$state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)

        $matchDocumentElement = $this.ParseDocumentElement($state)
        if($null -eq $matchDocumentElement) {
            $state.Pop()
            return $null
        }

        [MOFDocumentElement[]]$result = [MOFDocumentElement[]]@($matchDocumentElement)

        $matchAdditionalElements = $this.ParseDocumentElements($state)
        if($null -ne $matchAdditionalElements) {
            $result += $matchAdditionalElements
        }

        $this.ParseWhiteSpace($state)

        $state.Commit()

        return $result
    }   

    # DocumentElement => Comment | InstanceOf
    hidden [MOFDocumentElement] ParseDocumentElement([ParserState]$state)
    {
        $matchComment = $this.ParseComment($state)
        if($null -ne $matchComment) {
            return $matchComment
        }

        $matchInstanceOf = $this.ParseInstanceOf($state)
        if($null -ne $matchInstanceOf) {
            return $matchInstanceOf
        }

        return $null
    }

    # InstanceOf => WS* 'instance' WS+ 'of' WS+ LiteralName InstanceOfAs? StructureValue WS* ';'
    hidden [MOFInstanceOf] ParseInstanceOf([ParserState]$state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)

        $matchInstance = $state.MatchLiteralText('instance')
        if ($null -eq $matchInstance) {
            $state.Pop()
            return $null
        }

        $matchWs = $this.ParseWhiteSpace($state) 
        if ($null -eq $matchWS) {
            $state.Pop()
            return $null
        }

        $matchOf = $state.MatchLiteralText('of')
        if ($null -eq $matchOf) {
            $state.Pop()
            return $null
        }
        
        $matchWs = $this.ParseWhiteSpace($state) 
        if ($null -eq $matchWS) {
            $state.Pop()
            return $null
        }

        $matchLiteralName = $this.ParseLiteralName($state)
        if ($null -eq $matchLiteralName) {
            $state.Pop()
            return $null
        }
        
        $matchAs = $this.ParseInstanceOfAs($state)

        $matchValue = $this.ParseStructureValue($state)
        if ($null -eq $matchValue) {
            $state.Pop()
            return $null
        }

        $this.ParseWhiteSpace($state)

        $matchSemicolon = $state.MatchLiteralText(';')
        if ($null -eq $matchSemicolon) {
            $state.Pop()
            return $null
        }

        $state.Commit()
        return [MOFInstanceOf]::new(
            $matchLiteralName,
            $matchAs,
            $matchValue
        )
    }

    # StructureValue => WS* '{' Assignments WS* '}'
    hidden [MOFStructureValue] ParseStructureValue([ParserState]$state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state) 

        if(-not $state.MatchLiteralText('{')) {
            $state.Pop()
            return $null
        }

        $matchAssignments = $this.parseAssignments($state)
        
        $this.ParseWhiteSpace($state)

        if(-not $state.MatchLiteralText('}')) {
            $state.Pop()
            return $null
        }

        $state.Commit()

        return [MOFStructureValue]::new(
            $matchAssignments
        )
    }

    # Assignments => Assignment Assignments?
    hidden [MOFAssignment[]] ParseAssignments([ParserState]$state)
    {
        $state.Push()

        $matchAssignment = $this.ParseAssignment($state)
        if($null -eq $matchAssignment) {
            $state.Pop()
            return $null
        }

        $result = @($matchAssignment)

        $matchAssignments = $this.ParseAssignments($state)

        if($null -ne $matchAssignments) {
            $result += $matchAssignments
        }

        $state.Commit()
        return $result
    }

    # Assignment => WS* LiteralName WS* '=' Value WS* ';'
    hidden [MOFAssignment] ParseAssignment([ParserState] $state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)

        $matchLiteralName = $this.ParseLiteralName($state)
        if($null -eq $matchLiteralName) {
            $state.Pop()
            return $null
        }

        $this.ParseWhiteSpace($state)

        $matchAssignmentOperator = $state.MatchLiteralText('=')
        if($null -eq $matchAssignmentOperator) {
            $state.Pop()
            return $null
        }

        $matchValue = $this.ParseValue($state)
        if($null -eq $matchValue) {
            $state.Pop()
            return $null
        }

        $this.ParseWhiteSpace($state)

        $matchSemicolon = $state.MatchLiteralText(';')
        if($null -eq $matchSemicolon) {
            $state.Pop()
            return $null
        }

        $state.Commit()

        return [MOFAssignment]::new(
            $matchLiteralName,
            $matchValue
        )
    }

    # Value => Variable | StringValue | BooleanValue | IntegerValue | ArrayValue
    hidden [MOFValue] ParseValue([ParserState]$state)
    {
        $state.Push()

        $variableValue = $this.ParseVariable($state)
        if($null -ne $variableValue) {
            $state.Commit()
            return $variableValue
        }

        $stringValue = $this.ParseStringValue($state)
        if($null -ne $stringValue) {
            $state.Commit()
            return $stringValue
        }

        $booleanValue = $this.ParseBooleanValue($state)
        if($null -ne $booleanValue) {
            $state.Commit()
            return $booleanValue
        }

        $integerValue = $this.ParseIntegerValue($state)
        if($null -ne $integerValue) {
            $state.Commit()
            return $integerValue
        }

        $arrayValue = $this.ParseArrayValue($state)
        if($null -ne $arrayValue) {
            $state.Commit()
            return $arrayValue
        }

        Write-Host 'Unhandled value'

        $state.Pop()
        return $null
    }

    # IntegerValue => HexIntegerValue | DecimalIntegerValue 
    hidden [MOFIntegerValue] ParseIntegerValue([ParserState] $state)
    {
        $hexValue = $this.ParseHexIntegerValue($state)
        if($null -ne $hexValue) {
            return $hexValue
        }

        $decimalValue = $this.ParseDecimalIntegerValue($state)
        if($null -ne $decimalValue) {
            return $decimalValue
        }

        return $null
    }

    # HexIntegerValue = WS* '0x' [0-9a-fA-F]+
    hidden [MOFIntegerValue] ParseHexIntegerValue($state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)
        
        $matchZeroX = $state.MatchLiteralText('0x')
        if($null -eq $matchZeroX) {
            $state.Pop()
            return $null
        }

        $matchHexValue = $state.MatchExpression('[0-9a-fA-F]{1:16}')
        if($null -eq $matchHexValue) {
            $state.Pop()
            return $null
        }

        $state.Commit()
        return [MOFIntegerValue]::new([Convert]::ToInt64($matchHexValue.GetText(), 16))
    }

    # DecimalIntegerValue = WS* -?[0-9]+
    hidden [MOFIntegerValue] ParseDecimalIntegerValue($state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)
        
        $matchDecimalValue = $state.MatchExpression('-?[0-9]+')
        if($null -eq $matchDecimalValue) {
            $state.Pop()
            return $null
        }

        $decimalValue = $null
        try {
            $decimalValue = [Convert]::ToInt64($matchDecimalValue.GetText(), 10)
        } catch {
            Write-Host 'oops'
        }

        # TODO : Better checking of out of range here
        if([Convert]::ToInt64([Convert]::ToString($decimalValue)) -ne $decimalValue) {
            throw [System.ArgumentOutOfRangeException]::new(
                'Integer value out of range'
            )
        }

        $state.Commit()
        return [MOFIntegerValue]::new($decimalValue)
    }

    # ArrayValue => WS* '{' ArrayValueItems WS* '}'
    hidden [MOFArrayValue] ParseArrayValue([ParserState]$state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)

        $matchOpenBrace = $state.MatchLiteralText('{')
        if($null -eq $matchOpenBrace) {
            $state.Pop()
            return $null
        }

        $values = $this.ParseArrayValueItems($state)

        $this.ParseWhiteSpace($state)

        $matchCloseBrace = $state.MatchLiteralText('}')
        if($null -eq $matchCloseBrace) {
            $state.Pop()
            return $null
        }

        $state.Commit()
        return $values
    }

    # ArrayValueItems => Value WS* (',' Values)?
    hidden [MOFArrayValue] ParseArrayValueItems([ParserState]$state)
    {
        $state.Push()

        $values = [MOFValue[]]@()

        $value = $this.ParseValue($state)
        if($null -eq $value) {
            $state.Commit()
            return [MOFArrayValue]::new($values)
        }

        $values += $value

        $matchComma = $state.MatchLiteralText(',')
        if($null -ne $matchComma) {
            $matchValues = $this.ParseArrayValueItems($state)
            if($null -eq $matchValues) {
                throw [Exception]::new(
                    'Expected value'
                )
            }

            $values += $matchValues.Values
        }

        $state.Commit()
        return [MOFArrayValue]::new($values)
    }

    # BooleanValue => WS* ('True'|'False')
    hidden [MOFBooleanValue] ParseBooleanValue([ParserState]$state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)

        $matchTrue = $state.MatchLiteralText('True')
        if($null -ne $matchTrue) {
            $state.Commit()
            return [MOFBooleanValue]::new($true)
        }

        $matchFalse = $state.MatchLiteralText('False')
        if($null -ne $matchFalse) {
            $state.Commit()
            return [MOFBooleanValue]::new($false)
        }

        $state.Pop()
        return $null
    }

    # StringValue => WS* '"' StringPart? '"'
    hidden [MOFStringValue] ParseStringValue([ParserState]$state)
    {
        $state.Push()

        $this.ParseWhiteSpace($state)

        $matchStartingQuote = $state.MatchLiteralText('"')
        if($null -eq $matchStartingQuote) {
            $state.Pop()
            return $null
        }

        $result = [MOFStringValue]::new('')

        $matchStringPart = $this.ParseStringPart($state)
        if($null -ne $matchStringPart) {
            $result = $matchStringPart
        } 

        $matchStartingQuote = $state.MatchLiteralText('"')
        if($null -eq $matchStartingQuote) {
            $state.Pop()
            return $null
        }

        $state.Commit()

        return $result
    }

    # StringPart => StringPartSegment StringPart?
    hidden [MOFStringValue] ParseStringPart([ParserState]$state)
    {
        $state.Push()

        $matchStringPart = $this.ParseStringPartSegment($state)
        if($null -eq $matchStringPart) {
            $state.Pop()
            return $null
        }

        $nextStringPart = $this.ParseStringPart($state)
        if($null -ne $nextStringPart) {
            $matchStringPart.Value += $nextStringPart.Value
        }

        $state.Commit()

        return $matchStringPart
    }

    # StringPartSegment => EscapedStringPart | [^\\"]+
    hidden [MOFStringValue] ParseStringPartSegment([ParserState]$state)
    {
        $matchEscapedStringPart = $this.ParseEscapedStringPart($state)
        if($null -ne $matchEscapedStringPart) {
            return $matchEscapedStringPart
        }

        $matchStringPartExpression = $state.MatchExpression('[^\\"]+')
        if($null -ne $matchStringPartExpression) {
            return [MOFStringValue]::new(
                $matchStringPartExpression.GetText()
            )
        }

        return $null
    }

    # EscapedStringPart => '\' .
    hidden [MOFStringValue] ParseEscapedStringPart([ParserState]$state)
    {
        $state.Push()

        $matchBackslash = $state.MatchLiteralText('\')
        if($null -eq $matchBackslash) {
            $state.Pop()
            return $null
        }

        if($state.AtEnd()) {
            $state.Pop()
            return $null
        }

        $nextChar = $state.GetNextChar()

        $result = switch($nextChar) {
            'n' { "`n" }
            'r' { "`r" }
            't' { "`t" }
            'f' { "`t" }
            default { $nextChar }
        }

        # TODO : Handle more complex escape sequences... like \u001B

        $state.Commit()

        return [MOFStringValue]::new($result)
    }

    # InstanceOfAs => WS* 'as' WS+ Variable
    hidden [MOFInstanceOfAs] ParseInstanceOfAs([ParserState]$state)
    {
        $state.Push()

        $matchWs = $this.ParseWhiteSpace($state)
        if($null -eq $matchWs) {
            $state.Pop()
            return $null
        }

        $matchAs = $state.MatchLiteralText('as')
        if($null -eq $matchAs) {
            $state.Pop()
            return $null
        }

        $matchWs = $this.ParseWhiteSpace($state)
        if($null -eq $matchWs) {
            $state.Pop()
            return $null
        }

        $matchVariable = $this.ParseVariable([ParserState]$state)
        if($null -eq $matchVariable) {
            $state.Pop()
            return $null
        }

        $state.Commit()

        return [MOFInstanceOfAs]::new($matchVariable)
    }

    # Variable => WS* '\$_?([A-Za-z][A-Za-z0-9_]*)'
    hidden [MOFVariable] ParseVariable([ParserState]$state)
    {
        $state.Push()
        $this.ParseWhiteSpace($state)

        $matchVariable = $state.MatchExpression('\$_?([A-Za-z][A-Za-z0-9_]*)')
        if ($null -eq $matchVariable) {
            $state.Pop()
            return $null
        }

        $result = [MOFVariable]::new(
            $matchVariable.GetText()
        )

        $state.Commit()

        return $result
    }
    
    # LiteralName = '_?[A-Za-z][A-Za-z_]*'
    hidden [MOFLiteralName] ParseLiteralName([ParserState]$state)
    {
        $matchLiteralName = $state.MatchExpression('_?[A-Za-z][A-Za-z_]*')
        if ($null -eq $matchLiteralName) {
            return $null
        }

        $result = [MOFLiteralName]::new(
            $matchLiteralName.GetText()
        )

        return $result
    }

    # WS = '\s+'
    hidden [MOFWhiteSpace] ParseWhiteSpace([ParserState]$state)
    {
        $matchWhitespace = $state.MatchExpression('\s+')
        if ($null -ne $matchWhitespace) {
            $result = [MOFWhiteSpace]::new(
                $matchWhiteSpace.GetText()
            )

            return $result
        }

        return $null
    }

    # Comment => BlockComment
    hidden [MOFComment] ParseComment([ParserState]$state)
    {
        $parseBlockComment = $this.ParseBlockComment($state)
        if($null -ne $parseBlockComment) {
            return $parseBlockComment
        }

        return $null
    }

    # BlockComment => '\/\*(\*(?!\/)|[^*])*\*\/'
    hidden [MOFComment] ParseBlockComment([ParserState]$state)
    {
        # Attempt to match multi-line comments
        $matchComment = $state.MatchExpression('\/\*(\*(?!\/)|[^*])*\*\/')
        if ($null -ne $matchComment) {
            return [MOFComment]::new(
                $matchComment
            )
        }

        return $null
    }
}

<#
    .SYNOPSIS
        Reads the names of the DSC resource dependencies from a MOF file

    .DESCRIPTION
        Parses the MOF file provided by the MOFPath parameter and then walks the AST generated to find MOF entries
        that are instances of other types. For those instances, the values are checked for 'ModuleName' references.
        If there is a module name reference, then the name is extracted and returned. Only unique entries are returned.

    .PARAMETER MOFPath
        The path to the MOF file to read and extract DSC resources from
#>
Function Get-DSCResourceDependenciesFromMOF
{
    Param(
        [Parameter(Mandatory)]
        [string]$MOFPath
    )

    $mofText = Get-Content -Path $MOFPath

    $result = $null
    try {
        $testMOFParser = [MOFParser]::new()
        $result = $testMOFParser.Parse($mofText)
    } catch {
        #Set-Content -Path 'C:\temp\oops.mof' -Value $mofText

        throw [Exception]::new(
            'Failed to parse ' + $MOFPath,
            $_.Exception
        )
    }

    if($null -eq $result) {
        throw [Exception]::new(
            'Failed to parse ' + $MOFPath
        )
    }

    $instanceOfObjects = $result.Where{
        $_ -is [MOFInstanceOf] -and 
        ($null -ne ($_ -as [MOFInstanceOf]).As) 
    }

    if ($null -eq $instanceOfObjects) {
        return $null
    }

    $dscResourceModuleNames = $instanceOfObjects.ForEach{
        $_.Value.Values.Where{ 
            $_.Name.Name -eq 'ModuleName' -and 
            $_.Value -is [MOFStringValue] 
        }
    }.ForEach{
        $_.Value.Value
    } | Select-Object -Unique

    return $dscResourceModuleNames
}

<#
This code is written and maintained by Darren R. Starr from Conscia Norway AS.

License :

Copyright (c) 2017 Conscia Norway AS

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without limitation 
the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the Software 
is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#>

<#
    .SYNOPSIS
        Container for storing information about files to be copied from a host system to a VHD

    .DESCRIPTION
        This component is part of the MOFUtilities which can be used to copy DSC Resources in an offline
        fashion from a host computer to a .VHDX file for the purpose of making a MOF file able to run
        before network connectivity is established for a VM.
#>
class cDSCResourceManifestItem
{
    <#
        .SYNOPSIS
            A file system reference to the source file or directory item to be copied
    #>
    [System.IO.FileSystemInfo]$Item

    <#
        .SYNOPSIS
            A path to the item relative to the root of the DSC resource it belongs to
    #>
    [string]$RelativePath

    <#
        .SYNOPSIS
            The recommendation of where to copy the file relative to the root of the VHDX file
    #>
    [string]$RecommendedDestinationPath
}

<#
This code is written and maintained by Darren R. Starr from Conscia Norway AS.

License :

Copyright (c) 2017 Conscia Norway AS

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without limitation 
the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the Software 
is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#>

# TODO: Horrible hack to make sure that Get-DSCResource and all related types are available
Get-Command -Name 'Get-DSCResource' | Out-Null

<#
    .SYNOPSIS
        A class to identify and catalog information about a DSC resource locally available and where to copy it within a VHD 
        for offline installation.

    .DESCRIPTION
        cDSCResourceInformation, when provided with a DSC Resource module name identifies :
            <li>all the files that incorporate the</li>
            <li>whether the resource is a system resource (installed under system32)</li>
            <li>recommends where to copy the files (individually) relative to the root of a Windows VHD</li>

    .NOTES
        There are some oddities as to the implementation of this class. There are certain leaps of faith with regards
        to where the files are found (classifying them) and as to where to copy them (hard coded destination paths).
        Ideally, location roots would be identified via the system registry of the guest and host machines.

        This class has some groundwork implemented to identify whether the given DSC resource has any other module dependencies
        that should be able to be used to copy module dependencies as well. This has not been needed thus far, but may be needed later.
#>
class cDSCResourceInformation
{
    <#
        .SYNOPSIS
            The name of the DSC resource module
    #>
    [string]$ResourceName

    <#
        .SYNOPSIS
            The root directory of the version associated with the module
    #>
    [string]$VersionRootDirectory

    <#
        .SYNOPSIS
            The root directory of all versions of the module
    #>
    [string]$RootDirectory

    <#
        .SYNOPSIS
            The path of the PSD1 file within the module
    #>
    [string]$PSD1Path

    <#
        .SYNOPSIS
            Ther version number of the resource as reported by Get-DSCResource
    #>
    [string]$ResourceVersion

    <#
        .SYNOPSIS
            Is the module located in the System32 directory?
    #>
    [bool]$SystemModule

    <#
        .SYNOPSIS
            A manifest of files and directories to be copied to the VHD file. Recommended destination paths are also included.
    #>
    [cDSCResourceManifestItem[]]$Manifest

    <#
        .SYNOPSIS
            The destination root path of modules to be located under System32
    #>
    hidden static [string]$SystemModulePath = '\Windows\System32\WindowsPowerShell\v1.0\Modules'

    <#
        .SYNOPSIS
            The destination root path of modules to be located under program files
    #>
    hidden static [string]$ProgramFilesModulePath = '\Program Files\WindowsPowerShell\Modules'

    <#
        .SYNOPSIS
            The local system path for where System32 rooted modules should be found
    #>
    hidden static [string]$HostSystemModulePath = [cDSCResourceInformation]::GetExactPathName((Join-Path -Path $Env:windir -ChildPath 'System32\WindowsPowershell\v1.0\Modules'))

    <#
        .SYNOPSIS
            The local system path for where Program Files rooted modules should be found
    #>
    hidden static [string]$HostProgramFileModulePath = [cDSCResourceInformation]::GetExactPathName((Join-Path -Path $Env:ProgramFiles -ChildPath 'WindowsPowershell\Modules'))

    <#
        .SYNOPSIS
            Constructor and worker

        .DESCRIPTION
            The constructor queries the system for all pertainant information regarding the provided module name. It then makes
            a list of all the files within the module and calculated recommended destination paths for each item.
    #>
    cDSCResourceInformation([string]$name)
    {
        $this.ResourceName = $name

        # Find information about the resource from the system
        Write-Verbose -Message ('Calling Get-DscResource for module ' + $name)
        $resource = Get-DscResource -Module $name -Verbose:$false | Where-Object { $_.ModuleName -eq $Name } | Select-Object -Unique
        if($null -eq $resource) {
            throw [System.Exception]::new(
                'Invalid module name passed'
            )
        }

        if([string]::IsNullOrEmpty($resource.Path)) {
            throw [System.Exception]::new(
                'Cannot identify the path of where to find DSC resource [' + $name + ']'
            )
        }

        # Gather directory information
        $this.ResourceVersion = $resource.Version
        Write-Verbose -Message ('Resource version = ' + $this.ResourceVersion)

        $this.PSD1Path = $this.FindDSCResourcePSD1($resource.Path)
        Write-Verbose -Message ('PSD1 file = ' + $this.PSD1Path)

        $this.VersionRootDirectory = $this.GetDSCResourceVersionRootDirectory($this.PSD1Path)
        Write-Verbose -Message ('Version root directory = ' + $this.VersionRootDirectory)
        
        $this.RootDirectory = $this.GetDSCResourceRoot($this.VersionRootDirectory, $this.ResourceVersion)
        Write-Verbose -Message ('Resource root directory = ' + $this.RootDirectory)

        # Identify whether this is a system module (under System32)
        $this.SystemModule = [cDSCResourceInformation]::IsWindowsSystemModule($this.RootDirectory)
        Write-Verbose -Message ('Is system resource? ' + $this.SystemModule.ToString())

        # Catalog all files in the resource and produce a manifest for the copy operation.
        $dscResourceItems = Get-ChildItem -Path $this.VersionRootDirectory -Recurse
        $this.Manifest = $dscResourceItems.foreach{ 
            $relativePath = [cDSCResourceInformation]::GetRelativePath($this.VersionRootDirectory, $_.FullName)

            [cDSCResourceManifestItem] @{
                Item = $_
                RelativePath = $relativePath
                RecommendedDestinationPath = $this.GetRecommendedDestinationPath($relativePath)
            }
        }
    }

    <#
        .SYNOPSIS
            Overload of ToString() to make debugging easier
    #>
    [string]ToString()
    {
        return $this.ResourceName + ', ' + $this.ResourceVersion + ', ' + $this.RootDirectory + ', System?=' + $this.SystemModule.ToString()
    }

    <#
        .SYNOPSIS
            Checks to see whether the given path is rooted beneath %WINDIR%\System32
    #>
    hidden static [bool] IsWindowsSystemModule([string]$path)
    {
        return $path.StartsWith([cDSCResourceInformation]::HostSystemModulePath)
    }

    <#
        .SYNOPSIS
            Provides a recommendation for where to copy a file within a VHD file

        .DESCRIPTION
            For system modules, \Windows\System32\WindowsPowerShell\v1.0\Modules is used

            For non-system modules, \Program Files\WindowsPowerShell\Modules\{ResourceName}\{ResourceVersion} is used
    #>
    hidden [string] GetRecommendedDestinationPath([string]$RelativePath)
    {
        if($this.SystemModule) {
            return [System.IO.Path]::Combine([cDSCResourceInformation]::SystemModulePath)
        }

        return [System.IO.Path]::Combine(
            [System.IO.Path]::Combine([cDSCResourceInformation]::ProgramFilesModulePath, $this.ResourceName),
            $this.ResourceVersion
        )
    }

    <#
        .SYNOPSIS
            Returns the relative path from a base file path to a child file path.

        .NOTES
            This code may not be 100% Powershell Core friendly
    #>
    static hidden [string] GetRelativePath([string]$BasePath, [string]$ChildPath)
    {
        if(-not $BasePath.EndsWith('\')) {
            $BasePath += '\'
        }
            
        $basePathURI = [System.Uri]::new($BasePath)
        $childPathURI = [System.Uri]::new($ChildPath)

        $relativeUri = $basePathURI.MakeRelativeUri($childPathURI)

        return $relativeUri.ToString().Replace('/', '\')
    }

    <#
        .SYNOPSIS
            Given a full path name, resolves with correct case sensetivity of the path as is seen on the filesystem itself

        .NOTES
            This code was necessary because [System.IO.FileSystemInfo]::FullName does not resolve and correct paths
    #>
    static hidden [string] GetExactPathName([string]$PathName) 
    {
        if (-not (Test-Path -Path $PathName)) {
            return $PathName
        }

        $di = [System.IO.DirectoryInfo]::new($PathName)
        if ($null -ne $di.Parent) {
            return [System.IO.Path]::Combine(
                [cDSCResourceInformation]::GetExactPathName($di.Parent.FullName),
                $di.Parent.GetFileSystemInfos($di.Name)[0].Name
            )
        } else {
            return $di.Name.ToUpper()
        }
    }

    <#
        .SYNOPSIS
            From a given file or directory path, traverses the file path and locates a .PSD1 file to correlate to the module
    #>
    hidden [string] FindDSCResourcePSD1([string]$ResourcePath)
    {
        if(-not (Test-Path -Path $ResourcePath)) {
            throw [System.IO.FileNotFoundException](
                'Failed to find file',
                $ResourcePath
            )
        }

        Write-Verbose -Message ('Getting file system info for ' + $ResourcePath)
        $fi = [System.IO.FileInfo]::new($ResourcePath)
        if($fi.Extension.ToLower() -eq '.psd1') {
            return $ResourcePath
        }

        $resultPath = $fi.Directory.FullName
        while(-not [String]::IsNullOrEmpty($resultPath)) {
            $fi = [System.IO.FileInfo]::new($resultPath)

            Write-Verbose -Message ('Getting PSD1 files for ' + $fi.Directory.FullName)
            $psd1Files = $fi.Directory.GetFiles($this.ResourceName + '.psd1')
            if($null -ne $psd1Files) {
                if($psd1Files.Count -eq 1) {
                    return [cDSCResourceInformation]::GetExactPathName($psd1Files[0].FullName)
                }
            }

            $resultPath = $fi.Directory.FullName
        }

        if([String]::IsNullOrEmpty($resultPath)) {
            throw [System.Exception]::new(
                'Unhandled case, module ' + $this.ResourceName + ' is lacking a PSD1 file with the name [' + $this.ResourceName + '.psd1' 
            )
        }

        return [cDSCResourceInformation]::GetExactPathName($resultPath)
    }

    <#
        .SYNOPSIS
            Identifies the root path of a DSC resource from the path which contains the .PSD1 file

        .NOTES
            With Windows PowerShell 5 side-by-side module versioning, it is necessary to sometimes
            traverse upwards an additional level from where the .PSD1 is found
    #>
    hidden [string] GetDSCResourceRoot([string]$VersionRoot, [string]$Version)
    {
        if(-not (Test-Path -Path $VersionRoot -PathType Container)) {
            throw [System.IO.DirectoryNotFoundException]::new(
                'DSC Resource VersionRoot is not present'
            )
        }

        $di = [System.IO.DirectoryInfo]::new($VersionRoot)
        if($di.BaseName -eq $Version) {
            return [cDSCResourceInformation]::GetExactPathName($di.Parent.FullName)
        }

        return $VersionRoot
    }

    <#
        .SYNOPSIS
            Returns the directory containing the .PSD1 file for the given resource path.

        .NOTES
            TODO: This should be altered to use the PSD1 path instead of the resource path as the
            input variable
    #>
    hidden [string] GetDSCResourceVersionRootDirectory([string]$ResourcePath)
    {
        if(-not [String]::IsNullOrEmpty($ResourcePath)) {
            $psdPath = $this.FindDSCResourcePSD1($ResourcePath)
                        
            $fi = [System.IO.FileInfo]::new($psdPath)

            return $fi.Directory.FullName
        }

        return $null
    }

    <#
        .SYNOPSIS
            Reads the contents of a mpdule's PSD1 to identofy whether any other modules are listed as
            dependencies to this resource.
    #>
    hidden [string[]] GetResourceModuleDependencies([string]$PSD1Path)
    {
        $psdContent = Get-Content -Path $PSD1Path -raw
        $psd = Invoke-Expression -Command $psdContent
        return $psd.PSDModules
    }
}

<#
This code is written and maintained by Darren R. Starr from Conscia Norway AS.

License :

Copyright (c) 2017 Conscia Norway AS

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without limitation 
the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the Software 
is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#>

<#
    .SYNOPSIS
        A class to perform an offline installation of DSC resources needed by a MOF file

    .DESCRIPTION
        This class opens, parses and extracts a list of all DSC resource dependencies needed by
        a MOF file. Then it catalogs a manifest of all the files and directories needed for the
        DSC resources and copies them to a location, assumed to be the root directory of a mounted
        Windows Server VHD based virtual machine to the directory structure of that virtual machine.

  .AUTHOR
      Darren R. Starr
 
  .COPYRIGHT
      2017 Conscia Norway AS
 
    .NOTES
        I am not 1000% percent secure in my means of identifying the root of a DSC resource as
        there is no mechanism I could find on Get-DSCResource to return the GUID of the resource
        so I could read the contents of a PSD1 file and match it to the resource module.
#>
class cOfflineMOFDependencyInstaller
{
    <#
        .SYNOPSIS
            Read the contents of a MOF file and return DSC resource dependencies
    #>
    static hidden [string[]] GetDSCResourceDependenciesFromMOF([string]$MOFPath)
    {
        if(-not (Test-Path -Path $MOFPath)) {
            throw [System.IO.FileNotFoundException]::new(
                'MOF file [' + $MOFPath + '] not found'
            )
        }

        # Read the contents of the MOF file
        $mofText = Get-Content -Path $MOFPath

        # Attempt to parse the MOF file
        $result = $null
        try {
            $testMOFParser = [MOFParser]::new()
            $result = $testMOFParser.Parse($mofText)
        } catch {
            throw [Exception]::new(
                'Failed to parse ' + $MOFPath,
                $_.Exception
            )
        }

        # Throw an exception if there was no result
        if($null -eq $result) {
            throw [Exception]::new(
                'Failed to parse ' + $MOFPath
            )
        }

        # Find MOF objects which contain 'As' clauses
        $instanceOfObjects = $result.Where{
            $_ -is [MOFInstanceOf] -and 
            ($null -ne ($_ -as [MOFInstanceOf]).As) 
        }

        if ($null -eq $instanceOfObjects) {
            return $null
        }

        # Find the names of the module dependencies when inheriting using 'As'
        $dscResourceModuleNames = $instanceOfObjects.ForEach{
            $_.Value.Values.Where{ 
                $_.Name.Name -eq 'ModuleName' -and 
                $_.Value -is [MOFStringValue] 
            }
        }.ForEach{
            $_.Value.Value
        } | Select-Object -Unique

        return $dscResourceModuleNames
    }

    static [void]CopyMOFDependencies([string]$MOFPath, [string]$WindowsVHDRoot)
    {
        $dscResourceDependencies = [cOfflineMOFDependencyInstaller]::GetDSCResourceDependenciesFromMOF($MOFPath)
        Write-Verbose -Message ('Identified ' + $dscResourceDependencies.Count.ToString() + ' resource dependencies')
        $dscResourceDependencies.ForEach{ 
            Write-Verbose -Message ('Dependency - ' + $_)
        }

        $resources = $null
        try {
            $resources = $dscResourceDependencies.ForEach{ [cDSCResourceInformation]::new($_) }        
        } catch {
            Write-Verbose -Message ('Failed to get resource information for ' + $_)
            throw $_.Exception
        }
    
        $resources.ForEach{ 
            Write-Host $_

            $_.Manifest.ForEach{
                $destinationPath = Join-Path -Path $WindowsVHDRoot -ChildPath $_.RecommendedDestinationPath
                if(-not (Test-Path -Path $destinationPath)) {
                    Write-Verbose -Message ('  Creating - [' + $destinationPath + ']')
                    New-Item -Path $destinationPath -ItemType Directory
                }

                $itemDestinationPath = Join-Path -Path $destinationPath -ChildPath $_.RelativePath
                if($_.Item -is [System.IO.DirectoryInfo]) {
                    if(-not (Test-Path -Path $itemDestinationPath)) {
                        Write-Verbose ('  Creating - [' + $itemDestinationPath + ']')
                        New-Item -Path $itemDestinationPath -ItemType Directory
                    }
                } elseif($_.Item -is [System.IO.FileInfo]) {
                    if(-not (Test-Path -Path $itemDestinationPath)) {
                        Write-Verbose -Message ('    Copying - [' + $_.item.FullName + '] to [' + $itemDestinationPath + ']')
                        Copy-Item -Path $_.item.FullName -Destination $itemDestinationPath 
                    }
                } else {
                    throw [System.Exception]::new(
                        'Cannot process unknown file system type - ' + $_.Item.FullName
                    )
                }
            } 
        }
    }
}

<#
This code is written and maintained by Darren R. Starr from Conscia Norway AS.

License :

Copyright (c) 2017 Conscia Norway AS

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without limitation 
the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the Software 
is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#>

<# 
    .SYNOPSIS
        A resource for copying files into the contents of a VHD file
#>
[DscResource()]
class cVHDFileSystem 
{
    [DscProperty(Key)]
    [string] $VHDPath

    [DSCProperty()]
    [bool] $OkIfMounted = $true

    [DSCProperty()]
    [UInt64] $OkIfOverBytes = 4MB

    [DSCProperty(Mandatory)]
    [string[]] $ItemList

    [DSCProperty()]
    [string] $InitialMOF

    [DSCProperty()]
    [string] $MOFPath

    <#
        .SYNOPSIS
            Resource Get
    #>
    [cVHDFileSystem] Get()
    {
        [cVHDFileSystem]$result = [cVHDFileSystem]::new()

        $result.VHDPath = $this.VHDPath

        return $result
    }

    <#
        .SYNOPSIS
            Resource Test
    #>
    [bool] Test()
    {
        Write-Verbose -Message ('Testing for presence of [' + $this.VHDPath +'])')
        if (-not (Test-Path -Path $this.VHDPath)) {
            Write-Verbose -Message('VHD File [' + $this.VHDPath + '] not present')
            return $false
        }

        if($this.OkIfOverBytes -gt 0) {
            Write-Verbose -Message ('OkIfOverBytes is ' + $this.OkIfOverBytes + ' bytes. Testing file size')
            $fileItem = Get-Item -Path $this.VHDPath

            if($null -eq $fileItem) {
                throw [System.Exception]::new(
                    'Failed to call Get-Item on ' + $this.VHDPath
                )
            }

            Write-Verbose ('File size is ' + $fileItem.Length.ToString() + ' bytes')
            if($fileItem.Length -gt $this.OkIfOverBytes) {
                Write-Verbose -Message 'Test condition met'
                return $true
            }

            return $false
        }

        Write-Verbose -Message ('Getting mounted information about VHD')
        try {
            $MountedDiskImage = Get-WmiObject -Namespace 'root\virtualization\v2' -query "SELECT * FROM MSVM_MountedStorageImage WHERE Name ='$($this.VHDPath.Replace("\", "\\"))'"

            if($null -ne $MountedDiskImage) {
                If($this.OkIfMounted) {
                    Write-Verbose -Message ('[' + $this.VHDPath + '], VHD is already mounted and OkIfMounted is $true, test is ok')
                    return $true
                }

                throw [System.Exception]::new(
                    '[' + $this.VHDPath + '], VHD is already mounted and cannot be altered in its current state'
                )
            }
        } catch {
            if($_.Exception.Message.StartsWith('[')) {
                throw $_.Exception
            }

            throw [System.Exception]::new(
                'Failed to get information from virtualization root regarding mounted images',
                $_.Exception
            )
        }

        # TODO : Add code to test contents of VHD against file list

        return $true
    }

    <#
        .SYNOPSIS
            Resource Set
    #>
    [void] Set()
    {
        Write-Verbose -Message ('Testing for presence of [' + $this.VHDPath +'])')
        if (-not (Test-Path -Path $this.VHDPath)) {
            throw [System.IO.FileNotFoundException]::new(
                'VHD File not present',
                $this.VHDPath
            )
        }

        Write-Verbose -Message ('Checking initial validity of item list')
        if($null -eq $this.ItemList) {
            throw [System.ArgumentNullException]::new(
                'No item list was passed',
                'ItemList'
            )
        }

        if((($this.ItemList.Count % 2) -eq 1) -or ($this.ItemList.Count -eq 0)) {
            throw [System.ArgumentException]::new(
                'ItemList must be formatted as a list of strings of source path and destination path.',
                'ItemList'
            )
        }

        if((-not [string]::IsNullOrEmpty($this.InitialMOF))) {
            if (-not (Test-Path -Path $this.InitialMOF)) {
                throw [System.IO.FileNotFoundException]::new(
                    'Initial MOF file is specified but can''t be found [' + $this.InitialMOF + ']',
                    'InitialMOF'
                )
            }

            if ([string]::IsNullOrEmpty($this.MOFPath)) {
                throw [System.ArgumentException]::new(
                    'Initial MOF file is specified, but there is no destination to copy it to specified',
                    'InitialMOF'
                )
            }

            Write-Verbose -Message ('InitialMOF = [' + $this.InitialMOF + '], MOFPath = [' + $this.MOFPath + ']')
        }

        Write-Verbose -Message ('ItemList meets preliminary checks')

        $this.MountVHDImage()

        try {
            $this.CopyItems()
            $this.CopyInitialMOFAndDependencies()
        } catch {
            Write-Verbose -Message $_.Exception.Message
            throw [System.Exception]::new(
                'File copy operation failed',
                $_.Exception                
            )
        } finally {
            $this.DismountVHDImage()
        }
    }

    hidden static [string]$GptTypeUEFISystem = '{c12a7328-f81f-11d2-ba4b-00a0c93ec93b}'
    hidden static [string]$GptTypeMicrosoftReserved = '{e3c9e316-0b5c-4db8-817d-f92df00215ae}'
    hidden static [string]$GptTypeMicrosoftBasic = '{ebd0a0a2-b9e5-4433-87c0-68b6b72699c7}'

    hidden [string] $WindowsPartitionRoot

    # TODO : Should be static
    hidden [string]$PushLCMConfig = 
@'
[DSCLocalConfigurationManager()]
Configuration LCMConfig
{
    Node localhost { 
        Settings {
            RefreshMode='Push'
            RebootNodeIfNeeded=$true
            ActionAfterReboot='ContinueConfiguration'
        }
    }
}
LCMConfig -OutputPath 'c:\Windows\Panther\lcmmof'
Set-DscLocalConfigurationManager -Path 'c:\Windows\Panther\lcmmof' -ComputerName 'localhost'
'@ 

    hidden [void] WritePushLCMConfig()
    {
        $pantherScriptPath = Join-Path -Path $this.WindowsPartitionRoot -ChildPath 'Windows\Panther\Scripts'
        Write-Verbose -Message ('Testing for presence of [' + $pantherScriptPath + ']')
        if(-not (Test-Path -Path $pantherScriptPath)) {
            Write-Verbose -Message ('Creating [' + $pantherScriptPath + ']')
            New-Item -Path $pantherScriptPath -ItemType Directory
        }

        Write-Verbose -Message 'Writing LCMSetPushLocal.ps1'
        $lcmConfigScriptPath = Join-Path -Path $pantherScriptPath -ChildPath 'LCMSetPushLocal.ps1'
        Set-Content -Path $lcmConfigScriptPath -Value $this.PushLCMConfig
    }

    hidden [void] CopyInitialMOFAndDependencies()
    {
        if([string]::IsNullOrEmpty($this.InitialMOF)) {
            Write-Verbose -Message 'No initial MOF specified'
            return
        }

        $fullMofPath = Join-Path -Path $this.WindowsPartitionRoot -ChildPath $this.MOFPath

        Write-Verbose -Message ('Checking for presence of MOF destination path [' + $fullMofPath + ']')
        if(-not (Test-Path -Path $fullMofPath)) {
            Write-Verbose -Message ('Creating [' + $fullMofPath + ']')
            New-Item -Path $fullMofPath -ItemType Directory
        }

        $fi = [System.IO.FileInfo]::new($this.InitialMOF)
        $initialMofDestination = Join-Path -Path $fullMofPath -ChildPath $fi.Name

        Write-Verbose -Message ('Copying [' + $this.InitialMOF + '] to [' + $initialMofDestination + ']')
        Copy-Item -Path $this.InitialMOF -Destination $initialMofDestination -Force

        Write-Verbose -Message ('Copying MOF DSC Resource Dependencies')
        [cOfflineMOFDependencyInstaller]::CopyMOFDependencies($this.InitialMOF, $this.WindowsPartitionRoot)

        $this.WritePushLCMConfig()
    }

    [void] CopyItems()
    {
        Write-Verbose -Message ('Refreshing PS Drive list')
        Get-PSDrive

        $itemCount = $this.ItemList.Count

        for($i = 0; $i -lt $itemCount; $i += 2) {
            $sourceItem = $this.ItemList[$i]
            $destinationItem = $this.ItemList[$i + 1]

            Write-Verbose -Message ('SourcePath = [' + $sourceItem + '], DestinationPath = [' + $destinationItem + ']')
            
            Write-Verbose -Message ('Verifying presence of source file [' + $sourceItem + ']')
            if(-not (Test-Path -Path $sourceItem)) {
                throw [System.IO.FileNotFoundException]::new(
                    'Source item not found',
                    $sourceItem
                )
            }

            $destinationPath = Join-Path -Path $this.WindowsPartitionRoot -ChildPath $destinationItem
            Write-Verbose -Message ('Checking for presence of destination file [' + $destinationPath + ']')
            if(Test-Path -Path $destinationItem) {
                throw [System.Exception]::new(
                    'Overwriting existing files is not currently supported [' + $destinationItem + ']'
                )
            }

            Write-Verbose -Message ('Constructing parent path name for [' + $destinationPath + ']')
            $destinationFileInfo = [System.IO.FileInfo]::new($destinationPath)
            $destinationParent = $destinationFileInfo.Directory.FullName

            Write-Verbose -Message ('Checking for parent directory of destination file [' + $destinationParent + ']')
            if (-not (Test-Path -Path $destinationParent)) {
                throw [System.IO.DirectoryNotFoundException]::new(
                    'Parent directory of destination item does not exist and force creation is not supported yet',
                    $destinationParent
                )
            }

            Write-Verbose -Message 'Parent directory exists, preparing to copy'

            $sourceFileItem = Get-Item -Path $sourceItem
            if ($sourceFileItem.GetType().Name -eq 'DirectoryInfo') {
                Write-Verbose -Message 'Source item is a directory'
                Copy-Item -Path $sourceItem -Destination $destinationPath -Recurse -Confirm:$false -Force
            } elseif ($sourceFileItem.GetType().Name -eq 'FileInfo') {
                Write-Verbose -Message 'Source item is a normal file'
                Copy-Item -Path $sourceItem -Destination $destinationPath -Confirm:$false -Force
            } else {
                Write-Verbose -Message 'WTF'
                throw [System.Exception]::new(
                    '[' + $sourceItem + '] is an unsupported type [' + $sourceFileItem.GetType() + ']'
                )
            }
        }
    }

    [void] MountVHDImage()
    {
        $vhd = $null
        try {
            Write-Verbose -Message ('Getting handle to the VHD file')
            $vhd = Get-Vhd -Path $this.VHDPath 
            if($null -eq $vhd) {
                throw [System.Exception]::new(
                    'Unknown error getting handle to the vhd'
                )
            }
        } catch {
            if($_.Exception.Message.BeginsWith('Unknown')) {
                throw $_.Exception
            }

            throw [System.Exception]::new(
                'Error obtaining VHD handle to ' + $this.VHDPath,
                $_.Exception
            )
        }

        $mountResult = $null
        try {
            Write-Verbose -Message ('Obtained VHD Handle, mounting VHD image')
            $mountResult = $vhd | Mount-VHD -Passthru
            if ($null -eq $mountResult) {
                throw [System.Exception]::new(
                    'Unknown error mounting VHD [' + $this.VHDPath + ']'
                )
            }
        } catch {
            if($_.Exception.Message.BeginsWith('Unknown')) {
                throw $_.Exception
            }

            throw [System.Exception]::new(
                'Error mounting VHD ' + $this.VHDPath,
                $_.Exception
            )            
        }

        try {
            Write-Verbose -Message 'Mounted VHD, getting windows disk handle'

            $disk = $mountResult | Get-Disk
            if ($null -eq $disk) {
                throw [System.Exception]::new(
                    'Failed to get disk handle'
                )
            }

            Write-Verbose -Message 'Obtained windows disk handle, getting partition table'

            $partitions = $disk | Get-Partition
            if ($null -eq $partitions) {
                throw [System.Exception]::new(
                    'Failed to get partition table'
                )
            }

            # TODO : Consider calling BCDBOOT to read the boot information for the drive.
            # TODO : Consider simply getting an NTFS partition with a drive letter assigned

            $windowsPartition = $null
            try {
                Write-Verbose -Message 'Obtained partition table, searching for first non-system and non-UEFI partition which has an assigned drive letter'
                $windowsPartition = $partitions | Where-Object { 
                    ($_.GptType -ne [cVhdFileSystem]::GptTypeUEFISystem) -and 
                    ($_.GptType -ne [cVhdFileSystem]::GptTypeMicrosoftReserved) -and 
                    ([char]::IsLetter($_.DriveLetter[0])) 
                }
            } catch {
                throw [System.Exception]::new(
                    'Failed to get a partition meeting the criteria of a Windows boot drive',
                    $_.Exception
                )
            }

            if ($null -eq $windowsPartition) {
                #TODO : Generate error if there is more than one item returned.
                throw [System.Exception]::new(
                    'Failed to find a non-UEFI or Reserved partition'
                )
            }

            Write-Verbose -Message ('Windows partition found, resolving drive letter')
            $this.WindowsPartitionRoot = $windowsPartition.DriveLetter + ':\'
            Write-Verbose -Message ('Windows drive root is ' + $this.WindowsPartitionRoot)

            try {
                Write-Verbose -Message ('Making drive root accessible to other commandlets')
                $psDrive = New-PSDrive -Name $windowsPartition.DriveLetter -PSProvider FileSystem -Root $this.WindowsPartitionRoot 
                if ($null -eq $psDrive) {
                    throw [System.Exception]::new(
                        'Unknown error when trying to make drive accessible to other commandlets'
                    )
                }
            } catch {
                if ($_.Exception.Message.BeginsWith('Unknown')) {
                    throw $_.Exception
                }

                throw [System.Exception]::new(
                    'Failed to make drive accessible to other commandlets',
                    $_.Exception
                )
            }

            Write-Verbose -Message ('Drive root now accessible to other commandlets')
        } catch {
            Write-Error -Message ('Failed to complete mounting system drive of [' + $this.VHDPath + '] dismounting image')

            try {
                $vhd | Dismount-VHD 
            } catch {
                Write-Error -Message ('Failed to unmount VHD')
            }

            $this.WindowsPartitionRoot = $null

            throw [System.Exception]::new(
                'Failed to complete mounting and making [' + $this.VHDPath + '] accessible to other commandslet',
                $_.Exception
            )
        } 
    }

    [void] DismountVHDImage()
    {
        $vhd = $null
        try {
            Write-Verbose -Message ('Getting handle to the VHD file')
            $vhd = Get-Vhd -Path $this.VHDPath 
            if($null -eq $vhd) {
                throw [System.Exception]::new(
                    'Unknown error getting handle to the vhd'
                )
            }
        } catch {
            if($_.Exception.Message.BeginsWith('Unknown')) {
                throw $_.Exception
            }

            throw [System.Exception]::new(
                'Error obtaining VHD handle to ' + $this.VHDPath,
                $_.Exception
            )
        }

        try {
            Write-Verbose -Message 'Dismounting VHD'
            $vhd | Dismount-VHD
        } catch {
            throw [System.Exception]::new(
                'Failed to dismount [' + $this.VHDPath + ']',
                $_.Exception
            )
        }
    }
}
<#
This code is written and maintained by Darren R. Starr from Conscia Norway AS.

License :

Copyright (c) 2017 Conscia Norway AS AS Norway

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without limitation 
the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the Software 
is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION 
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#>

<#
    .SYNOPSIS 
        Powershell DSC Resource to convert Windows Server 2016 ISO images to VHD files

    .DESCRIPTION
        While it would not be difficult to extend this class to support more than simply deploying 
        Windows Server 2016 as a virtual machine image for use with Hyper-V, it would take little
        effort to extend this resource to support all the features of Convert-WindowsImage.ps1 as
        found on the ISO itself.

        This intention of this resource is to create a base VHD image that can be used by differencing
        images for rapid deployment of data center resources using other resources within this series
        of resources.

    .NOTES
        There are some issue I'm less than happy with in this code.
            <li>This code is non-reentrant</li>
            While this is generally an issue, due to a limitation with Mount-DiskImage, when an ISO
            is mounted, it is not really possible to mount the same image twice and not lose track of
            its mount points.
            <li>New-PSDrive isn't cleaned up</li>
            The New-PSDrive mounted in this code does not have any cleanup code associated with it and 
            it should.
            <li>Error handling on image dismount in case of error</li>
            There is a case where Dismount-DiskImage is called during a catch and is not properly handled.
#>
[DscResource()]
class cWindowsVHD 
{
    [DscProperty(Key)]
    [string] $VHDPath

    [DSCProperty(Mandatory)]
    [string] $ISOPath

    [DSCProperty()]
    [string] $Edition = 'SERVERDATACENTERCORE'

    [DscProperty()]
    [UInt64] $MaximumSizeBytes = 100GB

    hidden [string] $ISORoot

    <#
        .SYNOPSIS
            Resource Get
    #>
    [cWindowsVHD] Get()
    {
        [cWindowsVHD]$result = [cWindowsVHD]::new()

        $vhd = Get-VHD -Path $this.VHDPath
        $result.MaximumSizeBytes = $vhd.Size

        return $result
    }

    <#
        .SYNOPSIS
            Resource Test
    #>
    [bool] Test()
    {
        If (-not (Test-Path -Path $this.ISOPath)) {
            throw [System.ArgumentException]::new(
                ('ISO file [' + $this.ISOPath + '] is not present'),
                '$ISOPath'
            )
        }

        If (-not (Test-Path -Path $this.VHDPath)) {
            Write-Verbose -Message('VHD File [' + $this.VHDPath + '] not present')
            return $false
        }

        return $true
    }

    <#
        .SYNOPSIS
            Resource Set
    #>
    [void] Set()
    {
        Write-Verbose -Message ('Checking for a preexisting VHD [' + $this.VHDPath + '] file')
        If (Test-Path -Path $this.VHDPath) {
            throw [Exception]::(
                'VHD File [' + $this.VHDPath + '] is already present'
            )
        }

        Write-Verbose -Message ('VHD does not exist, mounting ISO')
        $this.MountISO()

        try {
            Write-Verbose -Message ('Start conversion of Windows image to VHD')
            $this.ConvertWindowsImage()
        } catch {
            throw [Exception] (
                'Windows image conversion failed', 
                $_.Exception
            )
        } finally {
            $this.DismountISO()
        }
    }

    hidden [void] MountISO()
    {
        Write-Verbose -Message ('Testing for the presence of the ISO image [' + $this.ISOPath + ']')

        If (-not (Test-Path -Path $this.ISOPath)) {
            throw [System.ArgumentException]::new(
                ('ISO file [' + $this.ISOPath + '] is not present'),
                '$ISOPath'
            )
        }

        $mountIsoResult = $null
        try {
            Write-Verbose -Message ('Attempting to mount the ISO image [' + $this.ISOPath + ']')
            $mountIsoResult = Mount-DiskImage -ImagePath $this.ISOPath -PassThru
        } catch {
            throw [Exception]::New(
                'Failed to mount Windows ISO [' + $this.ISOPath + ']',
                $_.Exception
                )
        }

        try {
            Write-Verbose -Message ('ISO mounted, getting mount information (compensate for possible powershell bug in Mount-DiskImage)')
            # TODO : Refresh variable... might be a bug... see Convert-WindowsImage.
            $mountIsoResult = Get-DiskImage -ImagePath $this.ISOPath

            Write-Verbose -Message ('Attempting to get drive letter of where the ISO was mounted')
            $driveLetter = ($mountIsoResult | Get-Volume).DriveLetter

            $this.ISORoot = "$($driveLetter):\"
            Write-Verbose -Message ('The drive where the ISO is mounted is -> ' + $this.ISORoot)

            Write-Verbose -Message ('Attempting to register ' + $this.ISORoot + ' so that it may be accessible to Powershell')
            New-PSDrive -Name $driveLetter -PSProvider FileSystem -Root $this.ISORoot
        } Catch {
            Write-Verbose -Message ('Failed to complete making ISO accessible. Dismounting ISO')
            # TODO : Should I add an exception to the dismount operation?
            Dismount-DiskImage -ImagePath $this.ISOPath

            $this.ISORoot = $null

            throw [Exception]::new(
                'The Windows ISO Image [' + $this.ISOPath + '] mounted successfully but a drive letter could not be obtained',
                $_.Exception
            )
        }

        Write-Verbose -Message ('ISO mounted and accessible at [' + $this.ISORoot + ']')
    }

    hidden [void] DismountISO()
    {
        try {
            Write-Verbose -Message ('Getting mount information as to where ISO [' + $this.ISOPath + '] is mounted')
            # TODO : Refresh variable... might be a bug... see Convert-WindowsImage.
            $mountIsoResult = Get-DiskImage -ImagePath $this.ISOPath

            Write-Verbose -Message ('Attempting to get drive letter of where the ISO was mounted')
            $driveLetter = ($mountIsoResult | Get-Volume).DriveLetter

            $this.ISORoot = "$($driveLetter):\"
            Write-Verbose -Message ('The drive where the ISO is mounted is -> ' + $this.ISORoot)

#            Write-Verbose -Message ('Attempting to register ' + $this.ISORoot + ' so that it may be accessible to Powershell')
#            New-PSDrive -Name $driveLetter -PSProvider FileSystem -Root $this.ISORoot

            # TODO : Delete PS drive?

            Write-Verbose -Message ('Attempting to dismount ISO image')
            Dismount-DiskImage -ImagePath $this.ISOPath

            $this.ISORoot = $null
        } Catch {
            throw [Exception]::new(
                'The Windows ISO Image [' + $this.ISOPath + '] failed to dismount',
                $_.Exception
            )
        }        
    }

    hidden [void] ConvertWindowsImage()
    {
        $convertWindowsImageScriptPath = [cWindowsVHD]::JoinPath($this.ISORoot, 'NanoServer\NanoServerImageGenerator\Convert-WindowsImage.ps1')
        $installWimPath =[cWindowsVHD]::JoinPath($this.ISORoot, 'sources\install.wim')
        $temporaryConversionPath = [cWindowsVHD]::JoinPath($env:TEMP, 'ConvertWindowsImage')

        Write-Verbose -Message ('Convert-WindowsImage.ps1 should be located at -> ' + $convertWindowsImageScriptPath)
        Write-Verbose -Message ('install.wim should be located at -> ' + $installWimPath)
        Write-Verbose -Message ('Path to give to Convert-WindowsImage a a temporary directory is -> ' + $temporaryConversionPath)

        # TODO : Get-PSDrive seems to refresh the drives here which has been a problem with Join-Path and Test-Path. Is there a better way?
        Get-PSDrive
        
        if(-not (Test-Path -Path $convertWindowsImageScriptPath)) {
            throw [System.IO.FileNotFoundException]::new(
                'Is this not a Windows Server 2016 ISO?', 
                $convertWindowsImageScriptPath
            )
        }

        if(-not (Test-Path -Path $installWimPath)) {
            throw [System.IO.FileNotFoundException]::new(
                'The Windows ISO may be invalid', 
                $installWimPath
            )
        }

        if(Test-Path -Path $temporaryConversionPath) {
            Write-Verbose -Message ('The path [' + $temporaryConversionPath + '] is already present, attempting to remove it first')
            try {
                Remove-Item -Path $temporaryConversionPath -Recurse -Force -Confirm:$false
            } catch {
                throw [System.IO.IOException]::new(
                    'Failed to delete [' + $temporaryConversionPath + ']. This directory should not be present before using this function', 
                    $_.Exception
                )
            }
        }

        # TODO : The following should not be necessary, but I'm not convinced that Remove-Item will throw an exception properly
        if(Test-Path -Path $temporaryConversionPath) {
            throw [Exception]::new(
                'Failed to delete [' + $temporaryConversionPath + ']. This directory should not be present before using this function'
            )
        }

        try {
            Write-Verbose -Message ('Creating temporary path [' + $temporaryConversionPath + '] to use for image conversion operations')
            New-Item -Path $temporaryConversionPath -Confirm:$false -ItemType Directory -Force
        } catch {
            throw [Exception]::new(
                'Failed to create path [' + $temporaryConversionPath + ']. Cannot continue', 
                $_.Exception
            )
        }

        . $convertWindowsImageScriptPath

        $Params = @{
                SourcePath = $installWimPath
                Edition = $this.Edition 
                VHDPath = $this.VHDPath
                TempDirectory = $temporaryConversionPath 
                SizeBytes = $this.MaximumSizeBytes 
                VHDFormat = 'VHDX'
                DiskLayout = 'UEFI'
            }

        # Write-Verbose -Message ('-SourcePath ''' + $installWimPath + ''' -Edition ''' + $this.Edition + ''' -VHDPath ''' + $this.VHDPath + ''' -TempDirectory ''' + $temporaryConversionPath + ''' -VHDFormat VHDX -DiskLayout UEFI' )

        Write-Verbose -Message ('Initiating ISO to VHD conversion')
        Convert-WindowsImage @Params -Passthru 

        Write-Verbose -Message ('Conversion complete, removing temporary directory')
        try {
            Remove-Item -Path $temporaryConversionPath -Recurse -Force -Confirm:$false
        } catch {
            throw [System.IO.IOException]::new(
                'Failed to delete [' + $temporaryConversionPath + ']. This directory should be removed before continuing', 
                $_.Exception
            )
        }
    }
    
    <#
        .SYNOPSIS
            Dirty nasty hack to get the same functionality of Join-Path without the actual file system dependencies
    #>
    hidden static [string]JoinPath([string]$path, [string]$childPath)
    {
        return [System.IO.Path]::GetFullPath([System.IO.Path]::Combine($path, $childPath))
    }
}

